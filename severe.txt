# Landing

## Overview

This documentation contains product & developer information about **Severe**, design decisions, as well as a guide for installation, terms of service, and some internal features.

## Notes

> Technical writer: mafiaburn / 865736728626593802
>
> Owner: BACKWOODS / 875905681650249788
>
> \
> If there's any issues or proposed changes to be made to the documentation, please contact the technical writer.

# Landing

## Overview

This documentation contains product & developer information about **Severe**, design decisions, as well as a guide for installation, terms of service, and some internal features.

## Notes

> Technical writer: mafiaburn / 865736728626593802
>
> Owner: BACKWOODS / 875905681650249788
>
> \
> If there's any issues or proposed changes to be made to the documentation, please contact the technical writer.

# Installation

## Redistributes

* [Direct X End-User Runtime](https://www.microsoft.com/en-us/download/details.aspx?id=35)
* [Visual C++ Redistributes](https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170)

## Register

* After acquisition, and once after you get your license key (which should be in your direct-messages with the bot SBV2-WHITELIST-BOT (1134900862632865953)), you download the file which is located in the [#download](https://canary.discord.com/channels/876072383033798667/1194692050617127015) channel within buyers category. After the download is complete, you have to ensure your anti-virus is **off** by using either [Defender Control](https://github.com/pgkt04/defender-control), or [Winaero Tweaker](https://winaerotweaker.com/), after that it is as simple as running **software.exe**, clicking "Register", and putting in your credentials. Importantly, please note down your username and password either somewhere physically, or virtually (i.e: password managers). This will save you time and potentially money.

## Login

* We assume that you already have the binary file and your anti-virus is already off, the process is simply to press "Login", put in your credentials and proceed. That's it. In-case you're getting "HWID mismatch" error, you can go to our [KeyAuth](https://keyauth.cc/panel/SHELUV_PERKS/v-severe), login and reset it there, note that there's a 1 week cool-down in-between each reset so as to prevent account-sharing.

# Introduction

- [Environment](/docs/developer-guide/introduction/environment.md)
- [Memory](/docs/developer-guide/introduction/memory.md)

# Interpreter

## Overview

This is the "Script" tab within Severe, this is the place where you run your code. It contains simple syntax-highlighting, however it does not possess features such as error linting, type-checking, auto-completion, and many more features that a specialized code-editor/language server may traditionally have.

## Layout

The layout is simplistic, composing of a text-box, and 2 buttons on the bottom to execute, and restart the runtime.

<figure><img src="https://4071170929-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FYwO4wKqgUnhstqwOQpNG%2Fuploads%2Fd4eSaXrbZFVDBDzfnA6c%2Fimage.png?alt=media&#x26;token=434c3ebf-452f-4626-a9e3-f03d09a5b6fc" alt=""><figcaption></figcaption></figure>

# Memory Viewer

## Overview

If you're familiar with ReClass / Cheat Engine's "dissect structure" tool, this is basically just that minus the control that you have with ReClass, and/or Cheat Engine. The "MEM" tab essentially just iterates through all the offsets in the specified address, and displays its value in several data-types, ranging from dword (int32), double (f64), float (f32), string, and boolean. You're also able to copy and write to these offsets in such data-types. It also provides RTTI (Run-time type information) for offsets.&#x20;

## Layout

The first page that will be open once you navigate to this tab, is the DataModel address. once expanded you will see something like this.

<div align="left"><figure><img src="https://4071170929-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FYwO4wKqgUnhstqwOQpNG%2Fuploads%2FpXxpEhX8kGbQBTuswOxg%2Fimage.png?alt=media&#x26;token=bac3e9d2-f9b8-4795-8db2-17d1726fac3f" alt=""><figcaption></figcaption></figure></div>

The first pink hexadecimal number here (0x0), is offset. This number typically never changes if you're using a pointer for the same class of structure.

The second gray number (0x7ff6a1442b70) is the hexadecimal 64-bit address that this value points to. You can copy this value with the button "copy" at the bottom.

The text value pinkish (H7???) is the string value.

Next column, contains values, such as dword, qword, double, float, and bool. You can set these values accordingly with the buttons below.

# Syntax

Luau uses the baseline [syntax of Lua 5.1](https://www.lua.org/manual/5.1/manual.html#2). For detailed documentation, please refer to the Lua manual, this is an example:

```lua
local function tree_insert(tree, x)
    local lower, equal, greater = split(tree.root, x)
    if not equal then
        equal = {
            x = x,
            y = math.random(0, 2^31-1),
            left = nil,
            right = nil
        }
    end
    tree.root = merge3(lower, equal, greater)
end
```

Note that future versions of Lua extend the Lua 5.1 syntax with more features; Luau does support string literal extensions but does not support other 5.x additions; for details please refer to compatibility section.

The rest of this document documents additional syntax used in Luau.

## String literals <a href="#string-literals" id="string-literals"></a>

Luau implements support for hexadecimal (`\x`), Unicode (`\u`) and `\z` escapes for string literals. This syntax follows [Lua 5.3 syntax](https://www.lua.org/manual/5.3/manual.html#3.1):

* `\xAB` inserts a character with the code 0xAB into the string
* `\u{ABC}` inserts a UTF8 byte sequence that encodes U+0ABC character into the string (note that braces are mandatory)
* `\z` at the end of the line inside a string literal ignores all following whitespace including newlines, which can be helpful for breaking long literals into multiple lines.

## Number literals <a href="#number-literals" id="number-literals"></a>

In addition to basic integer and floating-point decimal numbers, Luau supports:

* Hexadecimal integer literals, `0xABC` or `0XABC`
* Binary integer literals, `0b01010101` or `0B01010101`
* Decimal separators in all integer literals, using `_` for readability: `1_048_576`, `0xFFFF_FFFF`, `0b_0101_0101`

Note that Luau only has a single number type, a 64-bit IEEE754 double precision number (which can represent integers up to 2^53 exactly), and larger integer literals are stored with precision loss.

## Continue statement <a href="#continue-statement" id="continue-statement"></a>

In addition to `break` in all loops, Luau supports `continue` statement. Similar to `break`, `continue` must be the last statement in the block.

Note that unlike `break`, `continue` is not a keyword. This is required to preserve backwards compatibility with existing code; so this is a `continue` statement:

```lua
if x < 0 then
    continue
end
```

Whereas this is a function call:

```lua
if x < 0 then
    continue()
end
```

When used in `repeat..until` loops, `continue` can not skip the declaration of a local variable if that local variable is used in the loop condition; code like this is invalid and won’t compile:

```lua
repeat
    do continue end
    local a = 5
until a > 0
```

## Compound assignments <a href="#compound-assignments" id="compound-assignments"></a>

Luau supports compound assignments with the following operators: `+=`, `-=`, `*=`, `/=`, `//=`, `%=`, `^=`, `..=`. Just like regular assignments, compound assignments are statements, not expressions:

```lua
-- this works
a += 1

-- this doesn't work
print(a += 1)
```

Compound assignments only support a single value on the left and right hand side; additionally, the function calls on the left hand side are only evaluated once:

```lua
-- calls foo() twice
a[foo()] = a[foo()] + 1

-- calls foo() once
a[foo()] += 1
```

Compound assignments call the arithmetic metamethods (`__add` et al) and table indexing metamethods (`__index` and `__newindex`) as needed - for custom types no extra effort is necessary to support them.

## Type annotations <a href="#type-annotations" id="type-annotations"></a>

To support gradual typing, Luau supports optional type annotations for variables and functions, as well as declaring type aliases.

Types can be declared for local variables, function arguments and function return types using `:` as a separator:

```lua
function foo(x: number, y: string): boolean
    local k: string = y:rep(x)
    return k == "a"
end
```

In addition, the type of any expression can be overridden using a type cast `::`:

```lua
local k = (y :: string):rep(x)
```

There are several simple builtin types: `any` (represents inability of the type checker to reason about the type), `nil`, `boolean`, `number`, `string` and `thread`.

Function types are specified using the arguments and return types, separated with `->`:

```lua
local foo: (number, string) -> boolean
```

To return no values or more than one, you need to wrap the return type position with parentheses, and then list your types there.

```lua
local no_returns: (number, string) -> ()
local returns_boolean_and_string: (number, string) -> (boolean, string)

function foo(x: number, y: number): (number, string)
    return x + y, tostring(x) .. tostring(y)
end
```

Note that function types are specified without the argument names in the examples above, but it’s also possible to specify the names (that are not semantically significant but can show up in documentation and autocomplete):

```lua
local callback: (errorCode: number, errorText: string) -> ()
```

Table types are specified using the table literal syntax, using `:` to separate keys from values:

```lua
local array: { [number] : string }
local object: { x: number, y: string }
```

When the table consists of values keyed by numbers, it’s called an array-like table and has a special short-hand syntax, `{T}` (e.g. `{string}`).

Additionally, the type syntax supports type intersections (`((number) -> string) & ((boolean) -> string)`) and unions (`(number | boolean) -> string`). An intersection represents a type with values that conform to both sides at the same time, which is useful for overloaded functions; a union represents a type that can store values of either type - `any` is technically a union of all possible types.

It’s common in Lua for function arguments or other values to store either a value of a given type or `nil`; this is represented as a union (`number | nil`), but can be specified using `?` as a shorthand syntax (`number?`).

In addition to declaring types for a given value, Luau supports declaring type aliases via `type` syntax:

```lua
type Point = { x: number, y: number }
type Array<T> = { [number]: T }
type Something = typeof(string.gmatch("", "%d"))
```

The right hand side of the type alias can be a type definition or a `typeof` expression; `typeof` expression doesn’t evaluate its argument at runtime.

By default type aliases are local to the file they are declared in. To be able to use type aliases in other modules using `require`, they need to be exported:

```lua
export type Point = { x: number, y: number }
```

An exported type can be used in another module by prefixing its name with the require alias that you used to import the module.

```lua
local M = require(Other.Module)

local a: M.Point = {x=5, y=6}
```

For more information please refer to typechecking documentation.

### If-then-else expressions <a href="#if-then-else-expressions" id="if-then-else-expressions"></a>

In addition to supporting standard if *statements*, Luau adds support for if *expressions*. Syntactically, `if-then-else` expressions look very similar to if statements. However instead of conditionally executing blocks of code, if expressions conditionally evaluate expressions and return the value produced as a result. Also, unlike if statements, if expressions do not terminate with the `end` keyword.

Here is a simple example of an `if-then-else` expression:

```lua
local maxValue = if a > b then a else b
```

`if-then-else` expressions may occur in any place a regular expression is used. The `if-then-else` expression must match `if <expr> then <expr> else <expr>`; it can also contain an arbitrary number of `elseif` clauses, like `if <expr> then <expr> elseif <expr> then <expr> else <expr>`. Note that in either case, `else` is mandatory.

Here’s is an example demonstrating `elseif`:

```lua
local sign = if x < 0 then -1 elseif x > 0 then 1 else 0
```

**Note:** In Luau, the `if-then-else` expression is preferred vs the standard Lua idiom of writing `a and b or c` (which roughly simulates a ternary operator). However, the Lua idiom may return an unexpected result if `b` evaluates to false. The `if-then-else` expression will behave as expected in all situations.

## Generalized iteration <a href="#generalized-iteration" id="generalized-iteration"></a>

Luau uses the standard Lua syntax for iterating through containers, `for vars in values`, but extends the semantics with support for generalized iteration. In Lua, to iterate over a table you need to use an iterator like `next` or a function that returns one like `pairs` or `ipairs`. In Luau, you can simply iterate over a table:

```lua
for k, v in {1, 4, 9} do
    assert(k * k == v)
end
```

Further, iteration can be extended for tables or userdata by implementing the `__iter` metamethod which is called before the iteration begins, and should return an iterator function like `next` (or a custom one):

```lua
local obj = { items = {1, 4, 9} }
setmetatable(obj, { __iter = function(o) return next, o.items end })

for k, v in obj do
    assert(k * k == v)
end
```

The default iteration order for tables is specified to be consecutive for elements `1..#t` and unordered after that, visiting every element; similarly to iteration using `pairs`, modifying the table entries for keys other than the current one results in unspecified behavior.

## String interpolation <a href="#string-interpolation" id="string-interpolation"></a>

Luau adds an additional way to define string values that allows you to place runtime expressions directly inside specific spots of the literal.

This is a more ergonomic alternative over using `string.format` or `("literal"):format`.

To use string interpolation, use a backtick string literal:

```lua
local count = 3
print(`Bob has {count} apple(s)!`)
--> Bob has 3 apple(s)!
```

Any expression can be used inside `{}`:

```lua
local combos = {2, 7, 1, 8, 5}
print(`The lock combination is {table.concat(combos)}.`)
--> The lock combination is 27185.
```

Inside backtick string literal, `\` is used to escape `` ` ``, `{`, `\` itself and a newline:

```lua
print(`Some example escaping the braces \{like so}`)
--> Some example escaping the braces {like so}

print(`Backslash \ that escapes the space is not a part of the string...`)
--> Backslash  that escapes the space is not a part of the string...

print(`Backslash \\ will escape the second backslash...`)
--> Backslash \ will escape the second backslash...

print(`Some text that also includes \`...`)
--> Some text that also includes `...

local name = "Luau"

print(`Welcome to {
    name
}!`)
--> Welcome to Luau!
```

### Restrictions and limitations <a href="#restrictions-and-limitations" id="restrictions-and-limitations"></a>

The sequence of two opening braces `{{` is rejected with a parse error. This restriction is made to prevent developers using other programming languages with a similar feature from trying to attempt that as a way to escape a single `{` and getting unexpected results in Luau.

Luau currently does not support backtick string literals in type annotations, therefore `` type Foo = `Foo` `` is invalid syntax.

Unlike single and double-quoted string literals, backtick string literals must always be wrapped in parentheses for function calls:

```lua
print "hello" -- valid 
print`hello` -- invalid syntax
print(`hello`) -- valid
```

## Floor division (`//`) <a href="#floor-division" id="floor-division"></a>

Luau supports floor division, including its operator (`//`), its compound assignment operator (`//=`), and overloading metamethod (`__idiv`), as an ergonomic alternative to `math.floor`.

For numbers, `a // b` is equal to `math.floor(a / b)`:

```lua
local n = 6.72
print(n // 2) --> 3
n //= 3
print(n) --> 2
```

Note that it’s possible to get `inf`, `-inf`, or `NaN` with floor division; when `b` is `0`, `a // b` results in positive or negative infinity, and when both `a` and `b` are `0`, `a // b` results in NaN.

For native vectors, `c // d` applies `math.floor` to each component of the vector `c`. Therefore `c // d` is equivalent to `vector.create(math.floor(c.x / d), math.floor(c.y / b), math.floor(c.z / b))`.

Floor division syntax and semantics follow from [Lua 5.3](https://www.lua.org/manual/5.3/manual.html#3.4.1) where applicable.

# Typechecking

Luau supports a gradual type system through the use of type annotations and type inference.

### Type inference modes <a href="#type-inference-modes" id="type-inference-modes"></a>

There are three modes currently available. They must be annotated on the top few lines among the comments.

* `--!nocheck`,
* `--!nonstrict` (default), and
* `--!strict`

`nocheck` mode will simply not start the type inference engine whatsoever.

As for the other two, they are largely similar but with one important difference: in nonstrict mode, we infer `any` for most of the types if we couldn’t figure it out early enough. This means that given this snippet:

```lua
local foo = 1
```

We can infer `foo` to be of type `number`, whereas the `foo` in the snippet below is inferred `any`:

```lua
local foo
foo = 1
```

However, given the second snippet in strict mode, the type checker would be able to infer `number` for `foo`.

### Structural type system <a href="#structural-type-system" id="structural-type-system"></a>

Luau’s type system is structural by default, which is to say that we inspect the shape of two tables to see if they are similar enough. This was the obvious choice because Lua 5.1 is inherently structural.

```lua
type A = {x: number, y: number, z: number?}
type B = {x: number, y: number, z: number}

local a1: A = {x = 1, y = 2}        -- ok
local b1: B = {x = 1, y = 2, z = 3} -- ok

local a2: A = b1 -- ok
local b2: B = a1 -- not ok
```

### Builtin types <a href="#builtin-types" id="builtin-types"></a>

The Luau VM supports 10 primitive types: `nil`, `string`, `number`, `boolean`, `table`, `function`, `thread`, `userdata`, `vector`, and `buffer`. Of these, `table` and `function` are not represented by name, but have their dedicated syntax as covered in this syntax document, `userdata` is represented by [concrete types](#roblox-types), while `vector` is not representable by name at all; other types can be specified by their name.

The type checker also provides the builtin types [`unknown`](#unknown-type), [`never`](#never-type), and [`any`](#any-type).

```lua
local s = "foo"
local n = 1
local b = true
local t = coroutine.running()

local a: any = 1
print(a.x) -- Type checker believes this to be ok, but crashes at runtime.
```

There’s a special case where we intentionally avoid inferring `nil`. It’s a good thing because it’s never useful for a local variable to always be `nil`, thereby permitting you to assign things to it for Luau to infer that instead.

```lua
local a
local b = nil
```

#### `unknown` type <a href="#unknown-type" id="unknown-type"></a>

`unknown` is also said to be the *top* type, that is it’s a union of all types.

```lua
local a: unknown = "hello world!"
local b: unknown = 5
local c: unknown = function() return 5 end
```

Unlike `any`, `unknown` will not allow itself to be used as a different type!

```lua
local function unknown(): unknown
    return if math.random() > 0.5 then "hello world!" else 5
end

local a: string = unknown() -- not ok
local b: number = unknown() -- not ok
local c: string | number = unknown() -- not ok
```

In order to turn a variable of type `unknown` into a different type, you must apply [type refinements](#type-refinements) on that variable.

```lua
local x = unknown()
if typeof(x) == "number" then
    -- x : number
end
```

#### `never` type <a href="#never-type" id="never-type"></a>

`never` is also said to be the *bottom* type, meaning there doesn’t exist a value that inhabits the type `never`. In fact, it is the *dual* of `unknown`. `never` is useful in many scenarios, and one such use case is when type refinements proves it impossible:

```lua
local x = unknown()
if typeof(x) == "number" and typeof(x) == "string" then
    -- x : never
end
```

#### `any` type <a href="#any-type" id="any-type"></a>

`any` is just like `unknown`, except that it allows itself to be used as an arbitrary type without further checks or annotations. Essentially, it’s an opt-out from the type system entirely.

```lua
local x: any = 5
local y: string = x -- no type errors here!
```

### Function types <a href="#function-types" id="function-types"></a>

Let’s start with something simple.

```lua
local function f(x) return x end

local a: number = f(1)     -- ok
local b: string = f("foo") -- ok
local c: string = f(true)  -- not ok
```

In strict mode, the inferred type of this function `f` is `<A>(A) -> A` (take a look at [generics](#generics)), whereas in nonstrict we infer `(any) -> any`. We know this is true because `f` can take anything and then return that. If we used `x` with another concrete type, then we would end up inferring that.

Similarly, we can infer the types of the parameters with ease. By passing a parameter into *anything* that also has a type, we are saying “this and that has the same type.”

```lua
local function greetingsHelper(name: string)
    return "Hello, " .. name
end

local function greetings(name)
    return greetingsHelper(name)
end

print(greetings("Alexander"))          -- ok
print(greetings({name = "Alexander"})) -- not ok
```

### Table types <a href="#table-types" id="table-types"></a>

From the type checker perspective, each table can be in one of three states. They are: `unsealed table`, `sealed table`, and `generic table`. This is intended to represent how the table’s type is allowed to change.

#### Unsealed tables <a href="#unsealed-tables" id="unsealed-tables"></a>

An unsealed table is a table which supports adding new properties, which updates the tables type. Unsealed tables are created using table literals. This is one way to accumulate knowledge of the shape of this table.

```lua
local t = {x = 1} -- {x: number}
t.y = 2           -- {x: number, y: number}
t.z = 3           -- {x: number, y: number, z: number}
```

However, if this local were written as `local t: { x: number } = { x = 1 }`, it ends up sealing the table, so the two assignments henceforth will not be ok.

Furthermore, once we exit the scope where this unsealed table was created in, we seal it.

```lua
local function vec2(x, y)
    local t = {}
    t.x = x
    t.y = y
    return t
end

local v2 = vec2(1, 2)
v2.z = 3 -- not ok
```

Unsealed tables are *exact* in that any property of the table must be named by the type. Since Luau treats missing properties as having value `nil`, this means that we can treat an unsealed table which does not mention a property as if it mentioned the property, as long as that property is optional.

```lua
local t = {x = 1}
local u : { x : number, y : number? } = t -- ok because y is optional
local v : { x : number, z : number } = t  -- not ok because z is not optional
```

#### Sealed tables <a href="#sealed-tables" id="sealed-tables"></a>

A sealed table is a table that is now locked down. This occurs when the table type is spelled out explicitly via a type annotation, or if it is returned from a function.

```lua
local t : { x: number } = {x = 1}
t.y = 2 -- not ok
```

Sealed tables are *inexact* in that the table may have properties which are not mentioned in the type. As a result, sealed tables support *width subtyping*, which allows a table with more properties to be used as a table with fewer properties.

```lua
type Point1D = { x : number }
type Point2D = { x : number, y : number }
local p : Point2D = { x = 5, y = 37 }
local q : Point1D = p -- ok because Point2D has more properties than Point1D
```

#### Generic tables <a href="#generic-tables" id="generic-tables"></a>

This typically occurs when the symbol does not have any annotated types or were not inferred anything concrete. In this case, when you index on a parameter, you’re requesting that there is a table with a matching interface.

```lua
local function f(t)
    return t.x + t.y
           --^   --^ {x: _, y: _}
end

f({x = 1, y = 2})        -- ok
f({x = 1, y = 2, z = 3}) -- ok
f({x = 1})               -- not ok
```

### Table indexers <a href="#table-indexers" id="table-indexers"></a>

These are particularly useful for when your table is used similarly to an array.

```lua
local t = {"Hello", "world!"} -- {[number]: string}
print(table.concat(t, ", "))
```

Luau supports a concise declaration for array-like tables, `{T}` (for example, `{string}` is equivalent to `{[number]: string}`); the more explicit definition of an indexer is still useful when the key isn’t a number, or when the table has other fields like `{ [number]: string, n: number }`.

### Generics <a href="#generics" id="generics"></a>

The type inference engine was built from the ground up to recognize generics. A generic is simply a type parameter in which another type could be slotted in. It’s extremely useful because it allows the type inference engine to remember what the type actually is, unlike `any`.

```lua
type Pair<T> = {first: T, second: T }
-- generics can also have defaults!
type PairWithDefault<T = string> = Pair<T>

local strings: Pair<string> = { first="Hello", second="World" }
local numbers: Pair<number> = { first=1, second=2 }
-- can just treat PairWithDefault as a type that doesnt have generics because it has all of its generics assigned a default!
local more_strings: PairWithDefault = { first = "meow", second = "mrrp" }
```

### Generic functions <a href="#generic-functions" id="generic-functions"></a>

As well as generic type aliases like `Pair<T>`, Luau supports generic functions. These are functions that, as well as their regular data parameters, take type parameters. For example, a function which reverses an array is:

```lua
function reverse(a)
  local result = {}
  for i = #a, 1, -1 do
    table.insert(result, a[i])
  end
  return result
end
```

The type of this function is that it can reverse an array, and return an array of the same type. Luau can infer this type, but if you want to be explicit, you can declare the type parameter `T`, for example:

```lua
function reverse<T>(a: {T}): {T}
  local result: {T} = {}
  for i = #a, 1, -1 do
    table.insert(result, a[i])
  end
  return result
end
```

When a generic function is called, Luau infers type arguments, for example

```lua
local x: {number} = reverse({1, 2, 3})
local y: {string} = reverse({"a", "b", "c"})
```

Generic types are used for built-in functions as well as user functions, for example the type of two-argument `table.insert` is:

```lua
<T>({T}, T) -> ()
```

Note: Functions don’t support having defaults assigned to generics, meaning the following is invalid

```lua
function meow<T = string>(mrrp: T)
     print(mrrp .. " :3")
end
```

### Union types <a href="#union-types" id="union-types"></a>

A union type represents *one of* the types in this set. If you try to pass a union onto another thing that expects a *more specific* type, it will fail.

For example, what if this `string | number` was passed into something that expects `number`, but the passed in value was actually a `string`?

```lua
local stringOrNumber: string | number = "foo"

local onlyString: string = stringOrNumber -- not ok
local onlyNumber: number = stringOrNumber -- not ok
```

Note: it’s impossible to be able to call a function if there are two or more function types in this union.

### Intersection types <a href="#intersection-types" id="intersection-types"></a>

An intersection type represents *all of* the types in this set. It’s useful for two main things: to join multiple tables together, or to specify overloadable functions.

```lua
type XCoord = {x: number}
type YCoord = {y: number}
type ZCoord = {z: number}

type Vector2 = XCoord & YCoord
type Vector3 = XCoord & YCoord & ZCoord

local vec2: Vector2 = {x = 1, y = 2}        -- ok
local vec3: Vector3 = {x = 1, y = 2, z = 3} -- ok
```

```lua
type SimpleOverloadedFunction = ((string) -> number) & ((number) -> string)

local f: SimpleOverloadedFunction

local r1: number = f("foo") -- ok
local r2: number = f(12345) -- not ok
local r3: string = f("foo") -- not ok
local r4: string = f(12345) -- ok
```

Note: it’s impossible to create an intersection type of some primitive types, e.g. `string & number`, or `string & boolean`, or other variations thereof.

Note: Luau still does not support user-defined overloaded functions. Some of Roblox and Lua 5.1 functions have different function signature, so inherently requires overloaded functions.

### Singleton types (aka literal types) <a href="#singleton-types-aka-literal-types" id="singleton-types-aka-literal-types"></a>

Luau’s type system also supports singleton types, which means it’s a type that represents one single value at runtime. At this time, both string and booleans are representable in types.

> We do not currently support numbers as types. For now, this is intentional.

```lua
local foo: "Foo" = "Foo" -- ok
local bar: "Bar" = foo   -- not ok
local baz: string = foo  -- ok

local t: true = true -- ok
local f: false = false -- ok
```

This happens all the time, especially through [type refinements](#type-refinements) and is also incredibly useful when you want to enforce program invariants in the type system! See [tagged unions](#tagged-unions) for more information.

### Variadic types <a href="#variadic-types" id="variadic-types"></a>

Luau permits assigning a type to the `...` variadic symbol like any other parameter:

```lua
local function f(...: number)
end

f(1, 2, 3)     -- ok
f(1, "string") -- not ok
```

`f` accepts any number of `number` values.

In type annotations, this is written as `...T`:

```lua
type F = (...number) -> ...string
```

### Type packs <a href="#type-packs" id="type-packs"></a>

Multiple function return values as well as the function variadic parameter use a type pack to represent a list of types.

When a type alias is defined, generic type pack parameters can be used after the type parameters:

```lua
type Signal<T, U...> = { f: (T, U...) -> (), data: T }
```

> Keep in mind that `...T` is a variadic type pack (many elements of the same type `T`), while `U...` is a generic type pack that can contain zero or more types and they don’t have to be the same.

It is also possible for a generic function to reference a generic type pack from the generics list:

```lua
local function call<T, U...>(s: Signal<T, U...>, ...: U...)
    s.f(s.data, ...)
end
```

Generic types with type packs can be instantiated by providing a type pack:

```lua
local signal: Signal<string, (number, number, boolean)> = --

call(signal, 1, 2, false)
```

There are also other ways to instantiate types with generic type pack parameters:

```lua
type A<T, U...> = (T) -> U...

type B = A<number, ...string> -- with a variadic type pack
type C<S...> = A<number, S...> -- with a generic type pack
type D = A<number, ()> -- with an empty type pack
```

Trailing type pack argument can also be provided without parentheses by specifying variadic type arguments:

```lua
type List<Head, Rest...> = (Head, Rest...) -> ()

type B = List<number> -- Rest... is ()
type C = List<number, string, boolean> -- Rest is (string, boolean)

type Returns<T...> = () -> T...

-- When there are no type parameters, the list can be left empty
type D = Returns<> -- T... is ()
```

Type pack parameters are not limited to a single one, as many as required can be specified:

```lua
type Callback<Args..., Rets...> = { f: (Args...) -> Rets... }

type A = Callback<(number, string), ...number>
```

### Adding types for faux object oriented programs <a href="#adding-types-for-faux-object-oriented-programs" id="adding-types-for-faux-object-oriented-programs"></a>

One common pattern we see with existing Lua/Luau code is the following object-oriented code. While Luau is capable of inferring a decent chunk of this code, it cannot pin down on the types of `self` when it spans multiple methods.

```lua
local Account = {}
Account.__index = Account

function Account.new(name, balance)
    local self = {}
    self.name = name
    self.balance = balance

    return setmetatable(self, Account)
end

-- The `self` type is different from the type returned by `Account.new`
function Account:deposit(credit)
    self.balance += credit
end

-- The `self` type is different from the type returned by `Account.new`
function Account:withdraw(debit)
    self.balance -= debit
end

local account = Account.new("Alexander", 500)
```

For example, the type of `Account.new` is `<a, b>(name: a, balance: b) -> { ..., name: a, balance: b, ... }` (snipping out the metatable). For better or worse, this means you are allowed to call `Account.new(5, "hello")` as well as `Account.new({}, {})`. In this case, this is quite unfortunate, so your first attempt may be to add type annotations to the parameters `name` and `balance`.

There’s the next problem: the type of `self` is not shared across methods of `Account`, this is because you are allowed to explicitly opt for a different value to pass as `self` by writing `account.deposit(another_account, 50)`. As a result, the type of `Account:deposit` is `<a, b>(self: { balance: a }, credit: b) -> ()`. Consequently, Luau cannot infer the result of the `+` operation from `a` and `b`, so a type error is reported.

We can see there’s a lot of problems happening here. This is a case where you’ll have to provide some guidance to Luau in the form of annotations today, but the process is straightforward and without repetition. You first specify the type of *data* you want your class to have, and then you define the class type separately with `setmetatable` (either via `typeof`, or in the New Type Solver, the `setmetatable` type function). From then on, you can explicitly annotate the `self` type of each method with your class type! Note that while the definition is written e.g. `Account.deposit`, you can still call it as `account:deposit(...)`.

```lua
local Account = {}
Account.__index = Account

type AccountData = {
    name: string,
    balance: number,
}

export type Account = typeof(setmetatable({} :: AccountData, Account))
-- or alternatively, in the new type solver...
-- export type Account = setmetatable<AccountData, typeof(Account)>


-- this return annotation is not required, but ensures that you cannot
-- accidentally make the constructor incompatible with the methods
function Account.new(name, balance): Account
    local self = {}
    self.name = name
    self.balance = balance

    return setmetatable(self, Account)
end

-- this annotation on `self` is the only _required_ annotation.
function Account.deposit(self: Account, credit)
    -- autocomplete on `self` works here!
    self.balance += credit
end

-- this annotation on `self` is the only _required_ annotation.
function Account.withdraw(self: Account, debit)
    -- autocomplete on `self` works here!
    self.balance -= debit
end

local account = Account.new("Hina", 500)
account:deposit(20) -- this still works, and we had autocomplete after hitting `:`!
```

Based on feedback, we plan to restrict the types of all functions defined with `:` syntax to [share their self types](https://rfcs.luau.org/shared-self-types.html). This will enable future versions of this code to work without any explicit `self` annotations because it amounts to having type inference make precisely the assumptions we are encoding with annotations here — namely, that the type of the constructors and the method definitions is intended by the developer to be the same.

### Tagged unions <a href="#tagged-unions" id="tagged-unions"></a>

Tagged unions are just union types! In particular, they’re union types of tables where they have at least *some* common properties but the structure of the tables are different enough. Here’s one example:

```lua
type Ok<T> = { type: "ok", value: T }
type Err<E> = { type: "err", error: E }
type Result<T, E> = Ok<T> | Err<E>
```

This `Result<T, E>` type can be discriminated by using type refinements on the property `type`, like so:

```lua
if result.type == "ok" then
    -- result is known to be Ok<T>
    -- and attempting to index for error here will fail
    print(result.value)
elseif result.type == "err" then
    -- result is known to be Err<E>
    -- and attempting to index for value here will fail
    print(result.error)
end
```

Which works out because `value: T` exists only when `type` is in actual fact `"ok"`, and `error: E` exists only when `type` is in actual fact `"err"`.

### Type refinements <a href="#type-refinements" id="type-refinements"></a>

When we check the type of any lvalue (a global, a local, or a property), what we’re doing is we’re refining the type, hence “type refinement.” The support for this is arbitrarily complex, so go at it!

Here are all the ways you can refine:

1. Truthy test: `if x then` will refine `x` to be truthy.
2. Type guards: `if type(x) == "number" then` will refine `x` to be `number`.
3. Equality: `if x == "hello" then` will refine `x` to be a singleton type `"hello"`.

And they can be composed with many of `and`/`or`/`not`. `not`, just like `~=`, will flip the resulting refinements, that is `not x` will refine `x` to be falsy.

The `assert(..)` function may also be used to refine types instead of `if/then`.

Using truthy test:

```lua
local maybeString: string? = nil

if maybeString then
    local onlyString: string = maybeString -- ok
    local onlyNil: nil = maybeString       -- not ok
end

if not maybeString then
    local onlyString: string = maybeString -- not ok
    local onlyNil: nil = maybeString       -- ok
end
```

Using `type` test:

```lua
local stringOrNumber: string | number = "foo"

if type(stringOrNumber) == "string" then
    local onlyString: string = stringOrNumber -- ok
    local onlyNumber: number = stringOrNumber -- not ok
end

if type(stringOrNumber) ~= "string" then
    local onlyString: string = stringOrNumber -- not ok
    local onlyNumber: number = stringOrNumber -- ok
end
```

Using equality test:

```lua
local myString: string = f()

if myString == "hello" then
    local hello: "hello" = myString -- ok because it is absolutely "hello"!
    local copy: string = myString   -- ok
end
```

And as said earlier, we can compose as many of `and`/`or`/`not` as we wish with these refinements:

```lua
local function f(x: any, y: any)
    if (x == "hello" or x == "bye") and type(y) == "string" then
        -- x is of type "hello" | "bye"
        -- y is of type string
    end

    if not (x ~= "hi") then
        -- x is of type "hi"
    end
end
```

`assert` can also be used to refine in all the same ways:

```lua
local stringOrNumber: string | number = "foo"

assert(type(stringOrNumber) == "string")

local onlyString: string = stringOrNumber -- ok
local onlyNumber: number = stringOrNumber -- not ok
```

### Type casts <a href="#type-casts" id="type-casts"></a>

Expressions may be typecast using `::`. Typecasting is useful for specifying the type of an expression when the automatically inferred type is too generic.

For example, consider the following table constructor where the intent is to store a table of names:

```lua
local myTable = {names = {}}
table.insert(myTable.names, 42)         -- Inserting a number ought to cause a type error, but doesn't
```

In order to specify the type of the `names` table a typecast may be used:

```lua
local myTable = {names = {} :: {string}}
table.insert(myTable.names, 42)         -- not ok, invalid 'number' to 'string' conversion
```

A typecast itself is also type checked to ensure that one of the conversion operands is the subtype of the other or `any`:

```lua
local numericValue = 1
local value = numericValue :: any             -- ok, all expressions may be cast to 'any'
local flag = numericValue :: boolean          -- not ok, invalid 'number' to 'boolean' conversion
```

When typecasting a variadic or the result of a function with multiple returns, only the first value will be preserved. The rest will be discarded.

```lua
function returnsMultiple(...): (number, number, number)
    print(... :: string) -- "x"
    return 1, 2, 3
end

print(returnsMultiple("x", "y", "z")) -- 1, 2, 3
print(returnsMultiple("x", "y", "z") :: number) -- 1
```

### Roblox types <a href="#roblox-types" id="roblox-types"></a>

Roblox supports a rich set of classes and data types, [documented here](https://developer.roblox.com/en-us/api-reference). All of them are readily available for the type checker to use by their name (e.g. `Part` or `RaycastResult`).

When one type inherits from another type, the type checker models this relationship and allows to cast a subclass to the parent class implicitly, so you can pass a `Part` to a function that expects an `Instance`.

All enums are also available to use by their name as part of the `Enum` type library, e.g. `local m: Enum.Material = part.Material`.

We can automatically deduce what calls like `Instance.new` and `game:GetService` are supposed to return:

```lua
local part = Instance.new("Part")
local basePart: BasePart = part
```

Finally, Roblox types can be refined using `IsA`:

```lua
local function getText(x : Instance) : string
    if x:IsA("TextLabel") or x:IsA("TextButton") or x:IsA("TextBox") then
        return child.Text
    end
    return ""
end
```

Note that many of these types provide some properties and methods in both lowerCase and UpperCase; the lowerCase variants are deprecated, and the type system will ask you to use the UpperCase variants instead.

### Module interactions <a href="#module-interactions" id="module-interactions"></a>

Let’s say that we have two modules, `Foo` and `Bar`. Luau will try to resolve the paths if it can find any `require` in any scripts. In this case, when you say `script.Parent.Bar`, Luau will resolve it as: relative to this script, go to my parent and get that script named Bar.

```lua
-- Module Foo
local Bar = require(script.Parent.Bar)

local baz1: Bar.Baz = 1     -- not ok
local baz2: Bar.Baz = "foo" -- ok

print(Bar.Quux)         -- ok
print(Bar.FakeProperty) -- not ok

Bar.NewProperty = true -- not ok
```

```lua
-- Module Bar
export type Baz = string

local module = {}

module.Quux = "Hello, world!"

return module
```

There are some caveats here though. For instance, the require path must be resolvable statically, otherwise Luau cannot accurately type check it.

#### Cyclic module dependencies <a href="#cyclic-module-dependencies" id="cyclic-module-dependencies"></a>

Cyclic module dependencies can cause problems for the type checker. In order to break a module dependency cycle a typecast of the module to `any` may be used:

```lua
local myModule = require(MyModule) :: any
```

### Type functions <a href="#type-functions" id="type-functions"></a>

Type functions are functions that run during analysis time and operate on types, instead of runtime values. They can use the [types](#types-library) library to transform existing types or create new ones.

Here’s a simplified implementation of the builtin type function `keyof`. It takes a table type and returns its property names as a [union](about:blank/typecheck#union-types) of [singletons](about:blank/typecheck#singleton-types-aka-literal-types).

```lua
type function simple_keyof(ty)
    -- Ignoring unions or intersections of tables for simplicity.
    if not ty:is("table") then
        error("Can only call keyof on tables.")
    end

    local union = nil

    for property in ty:properties() do
        union = if union then types.unionof(union, property) else property
    end

    return if union then union else types.singleton(nil)
end

type person = {
    name: string,
    age: number,
}
--- keys = "age" | "name"
type keys = simple_keyof<person>
```

#### Type function environment <a href="#type-function-environment" id="type-function-environment"></a>

In addition to the [types](#types-library) library, type functions have access to:

* `assert`, `error`, `print`
* `next`, `ipairs`, `pairs`
* `select`, `unpack`
* `getmetatable`, `setmetatable`
* `rawget`, `rawset`, `rawlen`, `raweq`
* `tonumber`, `tostring`
* `type`, `typeof`
* `math` library
* `table` library
* `string` library
* `bit32` library
* `utf8` library
* `buffer` library

### types library <a href="#types-library" id="types-library"></a>

The `types` library is used to create and transform types, and can only be used within [type functions](#type-functions).

#### `types` library properties <a href="#types-library-properties" id="types-library-properties"></a>

```lua
types.any
```

The [any](about:blank/typecheck#any-type) `type`.

```lua
types.unknown
```

The [unknown](about:blank/typecheck#unknown-type) `type`.

```lua
types.never
```

The [never](about:blank/typecheck#never-type) `type`.

```lua
types.boolean
```

The boolean `type`.

```lua
types.buffer
```

The [buffer](about:blank/library#buffer-library) `type`.

```lua
types.number
```

The number `type`.

```lua
types.string
```

The string `type`.

```lua
types.thread
```

The thread `type`.

### `types` library functions <a href="#types-library-functions" id="types-library-functions"></a>

```lua
types.singleton(arg: string | boolean | nil): type
```

Returns the [singleton](about:blank/typecheck#singleton-types-aka-literal-types) type of the argument.

```lua
types.negationof(arg: type): type
```

Returns an immutable negation of the argument type.

```lua
types.optional(arg: type): type
```

Returns a version of the given type that is now optional.

* If the given type is a [union type](about:blank/\(typecheck#union-types\)), `nil` will be added unconditionally as a component.
* Otherwise, the result will be a union of the given type and the `nil` type.

```lua
types.unionof(first: type, second: type, ...: type): type
```

Returns an immutable [union](about:blank/typecheck#union-types) of two or more arguments.

```lua
types.intersectionof(first: type, second: type, ...: type): type
```

Returns an immutable [intersection](about:blank/typecheck#intersection-types) of two or more arguments.

```lua
types.newtable(props: { [type]: type | { read: type?, write: type? } }?, indexer: { index: type, readresult: type, writeresult: type? }?, metatable: type?): type
```

Returns a fresh, mutable table `type`. Property keys must be string singleton `type`s. The table’s metatable is set if one is provided.

```lua
types.newfunction(parameters: { head: {type}?, tail: type? }, returns: { head: {type}?, tail: type? }?, generics: {type}?): type
```

Returns a fresh, mutable function `type`, using the ordered parameters of `head` and the variadic tail of `tail`.

```lua
types.copy(arg: type): type
```

Returns a deep copy of the argument type.

```lua
types.generic(name: string?, ispack: boolean?): type
```

Creates a [generic](about:blank/typecheck#generic-functions) named `name`. If `ispack` is `true`, the result is a [generic pack](about:blank/typecheck#type-packs).

#### `type` instance <a href="#type-instance" id="type-instance"></a>

`type` instances can have extra properties and methods described in subsections depending on its tag.

```lua
type.tag: "nil" | "unknown" | "never" | "any" | "boolean" | "number" | "string" | "singleton" | "negation" | "union" | "intersection" | "table" | "function" | "class" | "thread" | "buffer"
```

An immutable property holding the type’s tag.

```lua
__eq(arg: type): boolean
```

Overrides the `==` operator to return `true` if `self` is syntactically equal to `arg`. This excludes semantically equivalent types, `true | false` is unequal to `boolean`.

```lua
type:is(arg: "nil" | "unknown" | "never" | "any" | "boolean" | "number" | "string" | "singleton" | "negation" | "union" | "intersection" | "table" | "function" | "class" | "thread" | "buffer")
```

Returns `true` if `self` has the argument as its tag.

#### Singleton `type` instance <a href="#singleton-type-instance" id="singleton-type-instance"></a>

```lua
singletontype:value(): boolean | nil | "string"
```

Returns the singleton’s actual value, like `true` for `types.singleton(true)`.

#### Generic `type` instance <a href="#generic-type-instance" id="generic-type-instance"></a>

```lua
generictype:name(): string?
```

Returns the name of the [generic](about:blank/typecheck#generic-functions) or `nil` if it has no name.

```lua
generictype:ispack(): boolean
```

Returns `true` if the [generic](about:blank/typecheck#generic-functions) is a [pack](about:blank/typecheck#type-packs), or `false` otherwise.

#### Table `type` instance <a href="#table-type-instance" id="table-type-instance"></a>

```lua
tabletype:setproperty(key: type, value: type?)
```

Sets the type of the property for the given `key`, using the same type for both reading from and writing to the table.

* `key` is expected to be a string singleton type, naming the property.
* `value` will be set as both the `read type` and `write type` of the property.
* If `value` is `nil`, the property is removed.

```lua
tabletype:setreadproperty(key: type, value: type?)
```

Sets the type for reading from the property named by `key`, leaving the type for writing this property as-is.

* `key` is expected to be a string singleton type, naming the property.
* `value` will be set as the `read type`, the `write type` will be unchanged.
* If `key` is not already present, only a `read type` will be set, making the property read-only.
* If `value` is `nil`, the property is removed.

```lua
tabletype:setwriteproperty(key: type, value: type?)
```

Sets the type for writing to the property named by `key`, leaving the type for reading this property as-is.

* `key` is expected to be a string singleton type, naming the property.
* `value` will be set as the `write type`, the `read type` will be unchanged.
* If `key` is not already present, only a `write type` will be set, making the property write-only.
* If `value` is `nil`, the property is removed.

```lua
tabletype:readproperty(key: type): type?
```

Returns the type used for reading values from this property, or `nil` if the property doesn’t exist.

```lua
tabletype:writeproperty(key: type): type?
```

Returns the type used for writing values to this property, or `nil` if the property doesn’t exist.

```lua
tabletype:properties(): { [type]: { read: type?, write: type? } }
```

Returns a table mapping property keys to their read and write types.

```lua
tabletype:setindexer(index: type, result: type)
```

Sets the table’s indexer, using the same type for reads and writes.

```lua
tabletype:setreadindexer(index: type, result: type)
```

Sets the type resulting from reading from this table via indexing.

```lua
tabletype:setwriteindexer(index: type, result: type)
```

Sets the type for writing to this table via indexing.

```lua
tabletype:indexer(): { index: type, readresult: type, writeresult: type }
```

Returns the table’s indexer as a table, or `nil` if it doesn’t exist.

```lua
tabletype:readindexer(): { index: type, result: type }?
```

Returns the table’s indexer using the result’s read type, or `nil` if it doesn’t exist.

```lua
tabletype:writeindexer()
```

Returns the table’s indexer using the result’s write type, or `nil` if it doesn’t exist.

```lua
tabletype:setmetatable(arg: type)
```

Sets the table’s metatable.

```lua
tabletype:metatable(): type?
```

Gets the table’s metatable, or `nil` if it doesn’t exist.

#### Function `type` instance <a href="#function-type-instance" id="function-type-instance"></a>

```lua
functiontype:setparameters(head: {type}?, tail: type?)
```

Sets the function’s parameters, with the ordered parameters in `head` and the variadic tail in `tail`.

```lua
functiontype:parameters(): { head: {type}?, tail: type? }
```

Returns the function’s parameters, with the ordered parameters in `head` and the variadic tail in `tail`.

```lua
functiontype:setreturns(head: {type}?, tail: type?)
```

Sets the function’s return types, with the ordered parameters in `head` and the variadic tail in `tail`.

```lua
functiontype:returns(): { head: {type}?, tail: type? }
```

Returns the function’s return types, with the ordered parameters in `head` and the variadic tail in `tail`.

```lua
functiontype:generics(): {type}
```

Returns an array of the function’s [generic](about:blank/typecheck#generic-functions) `type`s.

```lua
functiontype:setgenerics(generics: {type}?)
```

Sets the function’s [generic](about:blank/typecheck#generic-functions) `type`s.

#### Negation `type` instance <a href="#negation-type-instance" id="negation-type-instance"></a>

```lua
type:inner(): type
```

Returns the `type` being negated.

#### Union `type` instance <a href="#union-type-instance" id="union-type-instance"></a>

```lua
uniontype:components(): {type}
```

Returns an array of the [unioned](about:blank/typecheck#union-types) types.

#### Intersection `type` instance <a href="#intersection-type-instance" id="intersection-type-instance"></a>

```lua
intersectiontype:components()
```

Returns an array of the [intersected](about:blank/typecheck#intersection-types) types.

#### Class `type` instance <a href="#class-type-instance" id="class-type-instance"></a>

```lua
classtype:properties(): { [type]: { read: type?, write: type? } }
```

Returns the properties of the class with their respective `read` and `write` types.

```lua
classtype:readparent(): type?
```

Returns the type of reading this class’ parent, or returns `nil` if the parent class doesn’t exist.

```lua
classtype:writeparent(): type?
```

Returns the type for writing to this class’ parent, or returns `nil` if the parent class doesn’t exist.

```lua
classtype:metatable(): type?
```

Returns the class’ metatable, or `nil` if it doesn’t exist.

```lua
classtype:indexer(): { index: type, readresult: type, writeresult: type }?
```

Returns the class’ indexer, or `nil` if it doesn’t exist.

```lua
classtype:readindexer(): { index: type, result: type }?
```

Returns result type of reading from the class via indexing, or `nil` if it doesn’t exist.

```lua
classtype:writeindexer(): { index: type, result: type }?
```

Returns the type for writing to the class via indexing, or `nil` if it doesn’t exist.

# Performance

One of main goals of Luau is to enable high performance code, with gameplay code being the main use case. This can be viewed as two separate goals:

* Make idiomatic code that wasn’t tuned faster
* Enable even higher performance through careful tuning

Both of these goals are important - it’s insufficient to just focus on the highly tuned code, and all things being equal we prefer to raise all boats by implementing general optimizations. However, in some cases it’s important to be aware of optimizations that Luau does and doesn’t do.

Worth noting is that Luau is focused on, first and foremost, stable high performance code in interpreted context. This is because JIT compilation is not available on many platforms Luau runs on, and AOT compilation would only work for code that Roblox ships (and even that does not always work). This is in stark contrast with LuaJIT that, while providing an excellent interpreter as well, focuses a lot of the attention on JIT (with many optimizations unavailable in the interpreter).

Having said that, Luau has been updated to include an optional JIT component for x64 and arm64 platforms. This component can compile a selected set of functions, including limiting compilation to functions or modules marked explicitly by the user. While functions can be compiled at any time, automated JIT compilation decisions based on statistics/tracing are not performed. Luau JIT takes into account the type annotations present in the source code to specialize code paths and at this time, doesn’t include runtime analysis of the types/values flowing through the program.

The rest of this document goes into some optimizations that Luau employs and how to best leverage them when writing code. The document is not complete - a lot of optimizations are transparent to the user and involve detailed low-level tuning of various parts that is not described here - and all of this is subject to change without notice, as it doesn’t affect the semantics of valid code.

## Fast bytecode interpreter <a href="#fast-bytecode-interpreter" id="fast-bytecode-interpreter"></a>

Luau features a very highly tuned portable bytecode interpreter. It’s similar to Lua interpreter in that it’s written in C, but it’s highly tuned to yield efficient assembly when compiled with Clang and latest versions of MSVC. On some workloads it can match the performance of LuaJIT interpreter which is written in highly specialized assembly. We are continuing to tune the interpreter and the bytecode format over time; while extra performance can be extracted by rewriting the interpreter in assembly, we’re unlikely to ever do that as the extra gains at this point are marginal, and we gain a lot from C in terms of portability and being able to quickly implement new optimizations.

Of course the interpreter isn’t typical C code - it uses many tricks to achieve extreme levels of performance and to coerce the compiler to produce efficient assembly. Due to a better bytecode design and more efficient dispatch loop it’s noticeably faster than Lua 5.x (including Lua 5.4 which made some of the changes similar to Luau, but doesn’t come close). The bytecode design was partially inspired by excellent LuaJIT interpreter. Most computationally intensive scripts only use the interpreter core loop and builtins, which on x64 compiles into \~16 KB, thus leaving half of the instruction cache for other infrequently called code.

## Optimizing compiler <a href="#optimizing-compiler" id="optimizing-compiler"></a>

Unlike Lua and LuaJIT, Luau uses a multi-pass compiler with a frontend that parses source into an AST and a backend that generates bytecode from it. This carries a small penalty in terms of compilation time, but results in more flexible code and, crucially, makes it easier to optimize the generated bytecode.

> Note: Compilation throughput isn’t the main focus in Luau, but our compiler is reasonably fast; with all currently implemented optimizations enabled, it compiles 950K lines of Luau code in 1 second on a single core of a desktop Ryzen 5900X CPU, producing bytecode and debug information.

While bytecode optimizations are limited due to the flexibility of Luau code (e.g. `a * 1` may not be equivalent to `a` if `*` is overloaded through metatables), even in absence of type information Luau compiler can perform some optimizations such as “deep” constant folding across functions and local variables, perform upvalue optimizations for upvalues that aren’t mutated, do analysis of builtin function usage, optimize the instruction sequences for multiple variable assignments, and some peephole optimizations on the resulting bytecode. The compiler can also be instructed to use more aggressive optimizations by enabling optimization level 2 (`-O2` in CLI tools), some of which are documented further on this page.

Most bytecode optimizations are performed on individual statements or functions, however the compiler also does a limited amount of interprocedural optimizations; notably, calls to local functions can be optimized with the knowledge of the argument count or number of return values involved. Interprocedural optimizations are limited to a single module due to the compilation model.

Luau compiler is also able to use type information to do further optimizations. Because we control the entire stack (unlike e.g. TypeScript where the type information is discarded completely before reaching the VM), we have more flexibility there and can make some tradeoffs during codegen even if the type system isn’t completely sound. For example, it might be reasonable to assume that in presence of known types, we can infer absence of side effects for arithmetic operations and builtins - if the runtime types mismatch due to intentional violation of the type safety through global injection, the code will still be safely sandboxed. Type information is currently limited to small peephole optimizations, but it has a potential to unlock optimizations such as common subexpression elimination and allocation hoisting in the future, without having to rely on a JIT. These future optimizations opportunities are speculative pending further research.

## Epsilon-overhead debugger <a href="#epsilon-overhead-debugger" id="epsilon-overhead-debugger"></a>

It’s important for Luau to have stable and predictable performance. Something that comes up in Lua-based environments often is the use of line hooks to implement debugging (both for breakpoints and for stepping). This is problematic because the support for hooks is typically not free in general, but importantly once the hook is enabled, calling the hook has a considerable overhead, and the hook itself may be very costly to evaluate since it will need to associate the script:line pair with the breakpoint information.

Luau does not support hooks at all, and relies on first-class support for breakpoints (using bytecode patching) and single-stepping (using a custom interpreter loop) to implement debugging. As a result, the presence of breakpoints doesn’t slow the script execution down - the only noticeable discrepancy between running code under a debugger and without a debugger should be in cases where breakpoints are evaluated and skipped based on breakpoint conditions, or when stepping over long-running fragments of code.

## Inline caching for table and global access <a href="#inline-caching-for-table-and-global-access" id="inline-caching-for-table-and-global-access"></a>

Table access for field lookup is optimized in Luau using a mechanism that blends inline caching (classically used in Java/JavaScript VMs) and HREFs (implemented in LuaJIT). Compiler can predict the hash slot used by field lookup, and the VM can correct this prediction dynamically.

As a result, field access can be very fast in Luau, provided that:

* The field name is known at compile time. To make sure this is the case, `table.field` notation is recommended, although the compiler will also optimize `table["field"]` when the expression is known to be a constant string.
* The field access doesn’t use metatables. The fastest way to work with tables in Luau is to store fields directly inside the table, and store methods in the metatable (see below); access to “static” fields in classic OOP designs is best done through `Class.StaticField` instead of `object.StaticField`.
* The object structure is usually uniform. While it’s possible to use the same function to access tables of different shape - e.g. `function getX(obj) return obj.x end` can be used on any table that has a field `"x"` - it’s best to not vary the keys used in the tables too much, as it defeats this optimization.

The same optimization is applied to the custom globals declared in the script, although it’s best to avoid these altogether by using locals instead. Still, this means that the difference between `function` and `local function` is less pronounced in Luau.

## Importing global access chains <a href="#importing-global-access-chains" id="importing-global-access-chains"></a>

While global access for library functions can be optimized in a similar way, this optimization breaks down when the global table is using sandboxing through metatables, and even when globals aren’t sandboxed, `math.max` still requires two table accesses.

It’s always possible to “localize” the global accesses by using `local max = math.max`, but this is cumbersome - in practice it’s easy to forget to apply this optimization. To avoid relying on programmers remembering to do this, Luau implements a special optimization called “imports”, where most global chains such as `math.max` are resolved when the script is loaded instead of when the script is executed.

This optimization relies on being able to predict the shape of the environment table for a given function; this is possible due to global sandboxing, however this optimization is invalid in some cases:

* `loadstring` can load additional code that runs in context of the caller’s environment
* `getfenv`/`setfenv` can directly modify the environment of any function

The use of any of these functions performs a dynamic deoptimization, marking the affected environment as “impure”. The optimizations are only in effect on functions with “pure” environments - because of this, the use of `loadstring`/`getfenv`/`setfenv` is not recommended. Note that `getfenv` deoptimizes the environment even if it’s only used to read values from the environment.

> Note: Luau still supports these functions as part of our backwards compatibility promise, although we’d love to switch to Lua 5.2’s `_ENV` as that mechanism is cleaner and doesn’t require costly dynamic deoptimization.

## Fast method calls <a href="#fast-method-calls" id="fast-method-calls"></a>

Luau specializes method calls to improve their performance through a combination of compiler, VM and binding optimizations. Compiler emits a specialized instruction sequence when methods are called through `obj:Method` syntax (while this isn’t idiomatic anyway, you should avoid `obj.Method(obj)`). When the object in question is a Lua table, VM performs some voodoo magic based on inline caching to try to quickly discover the implementation of this method through the metatable.

For this to be effective, it’s crucial that `__index` in a metatable points to a table directly. For performance reasons it’s strongly recommended to avoid `__index` functions as well as deep `__index` chains; an ideal object in Luau is a table with a metatable that points to itself through `__index`.

When the object in question is a reflected userdata, a special mechanism called “namecall” is used to minimize the interop cost. In classical Lua binding model, `obj:Method` is called in two steps, retrieving the function object (`obj.Method`) and calling it; both steps are often implemented in C++, and the method retrieval needs to use a method object cache - all of this makes method calls slow.

Luau can directly call the method by name using the “namecall” extension, and an optimized reflection layer can retrieve the correct method quickly through more voodoo magic based on string interning and custom Luau features that aren’t exposed through Luau scripts.

As a result of both optimizations, common Lua tricks of caching the method in a local variable aren’t very productive in Luau and aren’t recommended either.

## Specialized builtin function calls <a href="#specialized-builtin-function-calls" id="specialized-builtin-function-calls"></a>

Due to global sandboxing and the ability to dynamically deoptimize code running in impure environments, in pure environments we go beyond optimizing the interpreter and optimize many built-in functions through a “fastcall” mechanism.

For this mechanism to work, function call must be “obvious” to the compiler - it needs to call a builtin function directly, e.g. `math.max(x, 1)`, although it also works if the function is “localized” (`local max = math.max`); this mechanism doesn’t work for indirect function calls unless they were inlined during compilation, and doesn’t work for method calls (so calling `string.byte` is more efficient than `s:byte`).

The mechanism works by directly invoking a highly specialized and optimized implementation of a builtin function from the interpreter core loop without setting up a stack frame and omitting other work; additionally, some fastcall specializations are partial in that they don’t support all types of arguments, for example all `math` library builtins are only specialized for numeric arguments, so calling `math.abs` with a string argument will fall back to the slower implementation that will do string->number coercion.

As a result, builtin calls are very fast in Luau - they are still slightly slower than core instructions such as arithmetic operations, but only slightly so. The set of fastcall builtins is slowly expanding over time and as of this writing contains `assert`, `type`, `typeof`, `rawget`/`rawset`/`rawequal`, `getmetatable`/`setmetatable`, `tonumber`/`tostring`, all functions from `math` (except `noise` and `random`/`randomseed`) and `bit32`, and some functions from `string` and `table` library.

Some builtin functions have partial specializations that reduce the cost of the common case further. Notably:

* `assert` is specialized for cases when the assertion return value is not used and the condition is truthy; this helps reduce the runtime cost of assertions to the extent possible
* `bit32.extract` is optimized further when field and width selectors are constant
* `select` is optimized when the second argument is `...`; in particular, `select(x, ...)` is O(1) when using the builtin dispatch mechanism even though it’s normally O(N) in variadic argument count.

Some functions from `math` library like `math.floor` can additionally take advantage of advanced SIMD instruction sets like SSE4.1 when available.

In addition to runtime optimizations for builtin calls, many builtin calls, as well as constants like `math.pi`/`math.huge`, can also be constant-folded by the bytecode compiler when using aggressive optimizations (level 2); this currently applies to most builtin calls with constant arguments and a single return value. For builtin calls that can not be constant folded, compiler assumes knowledge of argument/return count (level 2) to produce more efficient bytecode instructions.

## Optimized table iteration <a href="#optimized-table-iteration" id="optimized-table-iteration"></a>

Luau implements a fully generic iteration protocol; however, for iteration through tables in addition to generalized iteration (`for .. in t`) it recognizes three common idioms (`for .. in ipairs(t)`, `for .. in pairs(t)` and `for .. in next, t`) and emits specialized bytecode that is carefully optimized using custom internal iterators.

As a result, iteration through tables typically doesn’t result in function calls for every iteration; the performance of iteration using generalized iteration, `pairs` and `ipairs` is comparable, so generalized iteration (without the use of `pairs`/`ipairs`) is recommended unless the code needs to be compatible with vanilla Lua or the specific semantics of `ipairs` (which stops at the first `nil` element) is required. Additionally, using generalized iteration avoids calling `pairs` when the loop starts which can be noticeable when the table is very short.

Iterating through array-like tables using `for i=1,#t` tends to be slightly slower because of extra cost incurred when reading elements from the table.

## Optimized table length <a href="#optimized-table-length" id="optimized-table-length"></a>

Luau tables use a hybrid array/hash storage, like in Lua; in some sense “arrays” don’t truly exist and are an internal optimization, but some operations, notably `#t` and functions that depend on it, like `table.insert`, are defined by the Luau/Lua language to allow internal optimizations. Luau takes advantage of that fact.

Unlike Lua, Luau guarantees that the element at index `#t` is stored in the array part of the table. This can accelerate various table operations that use indices limited by `#t`, and this makes `#t` worst-case complexity O(logN), unlike Lua where the worst case complexity is O(N). This also accelerates computation of this value for small tables like `{ [1] = 1 }` since we never need to look at the hash part.

The “default” implementation of `#t` in both Lua and Luau is a binary search. Luau uses a special branch-free (depending on the compiler…) implementation of the binary search which results in 50+% faster computation of table length when it needs to be computed from scratch.

Additionally, Luau can cache the length of the table and adjust it following operations like `table.insert`/`table.remove`; this means that in practice, `#t` is almost always a constant time operation.

## Creating and modifying tables <a href="#creating-and-modifying-tables" id="creating-and-modifying-tables"></a>

Luau implements several optimizations for table creation. When creating object-like tables, it’s recommended to use table literals (`{ ... }`) and to specify all table fields in the literal in one go instead of assigning fields later; this triggers an optimization inspired by LuaJIT’s “table templates” and results in higher performance when creating objects. When creating array-like tables, if the maximum size of the table is known up front, it’s recommended to use `table.create` function which can create an empty table with preallocated storage, and optionally fill it with a given value.

When the exact table shape isn’t known, Luau compiler can still predict the table capacity required in case the table is initialized with an empty literal (`{}`) and filled with fields subsequently. For example, the following code creates a correctly sized table implicitly:

```
local v = {}
v.x = 1
v.y = 2
v.z = 3
return v
```

When appending elements to tables, it’s recommended to use `table.insert` (which is the fastest method to append an element to a table if the table size is not known). In cases when a table is filled sequentially, however, it can be more efficient to use a known index for insertion - together with preallocating tables using `table.create` this can result in much faster code, for example this is the fastest way to build a table of squares:

```
local t = table.create(N)

for i=1,N do
	t[i] = i * i
end
```

## Native vector math <a href="#native-vector-math" id="native-vector-math"></a>

Luau uses tagged value storage - each value contains a type tag and the data that represents the value of a given type. Because of the need to store 64-bit double precision numbers *and* 64-bit pointers, we don’t use NaN tagging and have to pay the cost of 16 bytes per value.

We take advantage of this to provide a native value type that can store a 32-bit floating point vector with 3 components. This type is fundamental to game computations and as such it’s important to optimize the storage and the operations with that type - our VM implements first class support for all math operations and component manipulation, which essentially means we have native 3-wide SIMD support. For code that uses many vector values this results in significantly smaller GC pressure and significantly faster execution, and gives programmers a mechanism to hand-vectorize numeric code if need be.

## Optimized upvalue storage <a href="#optimized-upvalue-storage" id="optimized-upvalue-storage"></a>

Lua implements upvalues as garbage collected objects that can point directly at the thread’s stack or, when the value leaves the stack frame (and is “closed”), store the value inside the object. This representation is necessary when upvalues are mutated, but inefficient when they aren’t - and 90% or more of upvalues aren’t mutated in typical Lua code. Luau takes advantage of this by reworking upvalue storage to prioritize immutable upvalues - capturing upvalues that don’t change doesn’t require extra allocations or upvalue closing, resulting in faster closure allocation, faster execution, faster garbage collection and faster upvalue access due to better memory locality.

Note that “immutable” in this case only refers to the variable itself - if the variable isn’t assigned to it can be captured by value, even if it’s a table that has its contents change.

When upvalues are mutable, they do require an extra allocated object; we carefully optimize the memory consumption and access cost for mutable upvalues to reduce the associated overhead.

## Closure caching <a href="#closure-caching" id="closure-caching"></a>

With optimized upvalue storage, creating new closures (function objects) is more efficient but still requires allocating a new object every time. This can be problematic for cases when functions are passed to algorithms like `table.sort` or functions like `pcall`, as it results in excessive allocation traffic which then leads to more work for garbage collector.

To make closure creation cheaper, Luau compiler implements closure caching - when multiple executions of the same function expression are guaranteed to result in the function object that is semantically identical, the compiler may cache the closure and always return the same object. This changes the function identity which may affect code that uses function objects as table keys, but preserves the calling semantics - compiler will only do this if calling the original (cached) function behaves the same way as a newly created function would. The heuristics used for this optimization are subject to change; currently, the compiler will cache closures that have no upvalues, or all upvalues are immutable (see previous section) and are declared at the module scope, as the module scope is (almost always) evaluated only once.

## Fast memory allocator <a href="#fast-memory-allocator" id="fast-memory-allocator"></a>

Similarly to LuaJIT, but unlike vanilla Lua, Luau implements a custom allocator that is highly specialized and tuned to the common allocation workloads we see. The allocator design is inspired by classic pool allocators as well as the excellent `mimalloc`, but through careful domain-specific tuning it beats all general purpose allocators we’ve tested, including `rpmalloc`, `mimalloc`, `jemalloc`, `ptmalloc` and `tcmalloc`.

This doesn’t mean that memory allocation in Luau is free - it’s carefully optimized, but it still carries a cost, and a high rate of allocations requires more work from the garbage collector. The garbage collector is incremental, so short of some edge cases this rarely results in visible GC pauses, but can impact the throughput since scripts will interrupt to perform “GC assists” (helping clean up the garbage). Thus for high performance Luau code it’s recommended to avoid allocating memory in tight loops, by avoiding temporary table and userdata creation.

In addition to a fast allocator, all frequently used structures in Luau have been optimized for memory consumption, especially on 64-bit platforms, compared to Lua 5.1 baseline. This helps to reduce heap memory footprint and improve performance in some cases by reducing the memory bandwidth impact of garbage collection.

## Optimized libraries <a href="#optimized-libraries" id="optimized-libraries"></a>

While the best performing code in Luau spends most of the time in the interpreter, performance of the standard library functions is critical to some applications. In addition to specializing many small and simple functions using the builtin call mechanism, we spend extra care on optimizing all library functions and providing additional functions beyond the Lua standard library that help achieve good performance with idiomatic code.

Functions from the `table` library like `insert`, `remove` and `move` have been tuned for performance on array-like tables, achieving 3x and more performance compared to un-tuned versions, and Luau provides additional functions like `table.create` and `table.find` to achieve further speedup when applicable. Our implementation of `table.sort` is using `introsort` algorithm which results in guaranteed worst case `NlogN` complexity regardless of the input, and, together with the array-like specializations, helps achieve \~4x speedup on average.

For `string` library, we use a carefully tuned dynamic string buffer implementation; it is optimized for smaller strings to reduce garbage created during string manipulation, and for larger strings it allows to produce a large string without extra copies, especially in cases where the resulting size is known ahead of time. Additionally, functions like `format` have been tuned to avoid the overhead of `sprintf` where possible, resulting in further speedups.

## Improved garbage collector pacing <a href="#improved-garbage-collector-pacing" id="improved-garbage-collector-pacing"></a>

Luau uses an incremental garbage collector which does a little bit of work every so often, and at no point does it stop the world to traverse the entire heap. The runtime will make sure that the collector runs interspersed with the program execution as the program allocates additional memory, which is known as “garbage collection assists”, and can also run in response to explicit garbage collection invocation via `lua_gc`. In interactive environments such as video game engines it’s possible, and even desirable, to request garbage collection every frame to make sure assists are minimized, since that allows scheduling the garbage collection to run concurrently with other engine processing that doesn’t involve script execution.

Inspired by excellent work by Austin Clements on Go’s garbage collector pacer, we’ve implemented a pacing algorithm that uses a proportional–integral–derivative controller to estimate internal garbage collector tunables to reach a target heap size, defined as a percentage of the live heap data (which is more intuitive and actionable than Lua 5.x “GC pause” setting). Luau runtime also estimates the allocation rate making it easy (given uniform allocation rates) to adjust the per-frame garbage collection requests to do most of the required GC work outside of script execution.

## Reduced garbage collector pauses <a href="#reduced-garbage-collector-pauses" id="reduced-garbage-collector-pauses"></a>

While Luau uses an incremental garbage collector, once per each collector cycle it runs a so-called “atomic” step. While all other GC steps can do very little work by only looking at a few objects at a given time, which means that the collector can have arbitrarily short pauses, the “atomic” step needs to traverse some amount of data that, in some cases, may scale with the application heap. Since atomic step is indivisible, it can result in occasional pauses on the order of tens of milliseconds, which is problematic for interactive applications. We’ve implemented a series of optimizations to help reduce the atomic step.

Normally objects that have been modified after the GC marked them in an incremental mark phase need to be rescanned during atomic phase, so frequent modifications of existing tables may result in a slow atomic step. To address this, we run a “remark” step where we traverse objects that have been modified after being marked once more (incrementally); additionally, the write barrier that triggers for object modifications changes the transition logic during remark phase to reduce the probability that the object will need to be rescanned.

Another source of scalability challenges is coroutines. Writes to coroutine stacks don’t use a write barrier, since that’s prohibitively expensive as they are too frequent. This means that coroutine stacks need to be traversed during atomic step, so applications with many coroutines suffer large atomic pauses. To address this, we implement incremental marking of coroutines: marking a coroutine makes it “inactive” and resuming a coroutine (or pushing extra objects on the coroutine stack via C API) makes it “active”. Atomic step only needs to traverse active coroutines again, which reduces the cost of atomic step by effectively making coroutine collection incremental as well.

While large tables can be a problem for incremental GC in general since currently marking a single object is indivisible, large weak tables are a unique challenge because they also need to be processed during atomic phase, and the main use case for weak tables - object caches - may result in tables with large capacity but few live objects in long-running applications that exhibit bursts of activity. To address this, weak tables in Luau can be marked as “shrinkable” by including `s` as part of `__mode` string, which results in weak tables being resized to the optimal capacity during GC. This option may result in missing keys during table iteration if the table is resized while iteration is in progress and as such is only recommended for use in specific circumstances.

## Optimized garbage collector sweeping <a href="#optimized-garbage-collector-sweeping" id="optimized-garbage-collector-sweeping"></a>

The incremental garbage collector in Luau runs three phases for each cycle: mark, atomic and sweep. Mark incrementally traverses all live objects, atomic finishes various operations that need to happen without mutator intervention (see previous section), and sweep traverses all objects in the heap, reclaiming memory used by dead objects and performing minor fixup for live objects. While objects allocated during the mark phase are traversed in the same cycle and thus may get reclaimed, objects allocated during the sweep phase are considered live. Because of this, the faster the sweep phase completes, the less garbage will accumulate; and, of course, the less time sweeping takes the less overhead there is from this phase of garbage collection on the process.

Since sweeping traverses the whole heap, we maximize the efficiency of this traversal by allocating garbage-collected objects of the same size in 16 KB pages, and traversing each page at a time, which is otherwise known as a paged sweeper. This ensures good locality of reference as consecutively swept objects are contiguous in memory, and allows us to spend no memory for each object on sweep-related data or allocation metadata, since paged sweeper doesn’t need to be able to free objects without knowing which page they are in. Compared to linked list based sweeping that Lua/LuaJIT implement, paged sweeper is 2-3x faster, and saves 16 bytes per object on 64-bit platforms.

## Function inlining and loop unrolling <a href="#function-inlining-and-loop-unrolling" id="function-inlining-and-loop-unrolling"></a>

By default, the bytecode compiler performs a series of optimizations that result in faster execution of the code, but they preserve both execution semantics and debuggability. For example, a function call is compiled as a function call, which may be observable via `debug.traceback`; a loop is compiled as a loop, which may be observable via `lua_getlocal`. To help improve performance in cases where these restrictions can be relaxed, the bytecode compiler implements additional optimizations when optimization level 2 is enabled (which requires using `-O2` switch when using Luau CLI), namely function inlining and loop unrolling.

Only loops with loop bounds known at compile time, such as `for i=1,4 do`, can be unrolled. The loop body must be simple enough for the optimization to be profitable; compiler uses heuristics to estimate the performance benefit and automatically decide if unrolling should be performed.

Only local functions (defined either as `local function foo` or `local foo = function`) can be inlined. The function body must be simple enough for the optimization to be profitable; compiler uses heuristics to estimate the performance benefit and automatically decide if each call to the function should be inlined instead. Additionally recursive invocations of a function can’t be inlined at this time, and inlining is completely disabled for modules that use `getfenv`/`setfenv` functions.

In both cases, in addition to removing the overhead associated with function calls or loop iteration, these optimizations can additionally benefit by enabling additional optimizations, such as constant folding of expressions dependent on loop iteration variable or constant function arguments, or using more efficient instructions for certain expressions when the inputs to these instructions are constants.

# Library

## Globals

While most library functions are provided as part of a library like `table`, a few global functions are exposed without extra namespacing.

### assert

```lua
function assert<T>(value: T, message: string?): T
```

`assert` checks if the value is truthy; if it's not (which means it's `false` or `nil`), it raises an error. The error message can be customized with an optional parameter. Upon success the function returns the `value` argument.

### error

```lua
function error(obj: any, level: number?)
```

`error` raises an error with the specified object. Note that errors don't have to be strings, although they often are by convention; various error handling mechanisms like `pcall` preserve the error type. When `level` is specified, the error raised is turned into a string that contains call frame information for the caller at level `level`, where `1` refers to the function that called `error`. This can be useful to attribute the errors to callers, for example `error("Expected a valid object", 2)` highlights the caller of the function that called `error` instead of the function itself in the callstack.

### gcinfo

```lua
function gcinfo(): number
```

`gcinfo` returns the total heap size in kilobytes, which includes bytecode objects, global tables as well as the script-allocated objects. Note that Luau uses an incremental garbage collector, and as such at any given point in time the heap may contain both reachable and unreachable objects. The number returned by `gcinfo` reflects the current heap consumption from the operating system perspective and can fluctuate over time as garbage collector frees objects.

### getfenv

```lua
function getfenv(target: (function | number)?): table
```

Returns the environment table for target function; when `target` is not a function, it must be a number corresponding to the caller stack index, where 1 means the function that calls `getfenv`, and the environment table is returned for the corresponding function from the call stack. When `target` is omitted it defaults to `1`, so `getfenv()` returns the environment table for the calling function.

### getmetatable

```lua
function getmetatable(obj: any): table?
```

Returns the metatable for the specified object; when object is not a table or a userdata, the returned metatable is shared between all objects of the same type. Note that when metatable is protected (has a `__metatable` key), the value corresponding to that key is returned instead and may not be a table.

### next

```lua
function next<K, V>(t: { [K]: V }, i: K?): (K, V)?
```

Given the table `t`, returns the next key-value pair after `i` in the table traversal order, or nothing if `i` is the last key. When `i` is `nil`, returns the first key-value pair instead.

### newproxy

```lua
function newproxy(mt: boolean?): userdata
```

Creates a new untyped userdata object; when `mt` is true, the new object has an empty metatable that can be modified using `getmetatable`.

### print

```lua
function print(args: ...any)
```

Prints all arguments to the standard output, using Tab as a separator.

### rawequal

```lua
function rawequal(a: any, b: any): boolean
```

Returns true iff `a` and `b` have the same type and point to the same object (for garbage collected types) or are equal (for value types).

### rawget

```lua
function rawget<K, V>(t: { [K]: V }, k: K): V?
```

Performs a table lookup with index `k` and returns the resulting value, if present in the table, or nil. This operation bypasses metatables/`__index`.

### rawset

```lua
function rawset<K, V>(t: { [K] : V }, k: K, v: V)
```

Assigns table field `k` to the value `v`. This operation bypasses metatables/`__newindex`.

### select

```lua
function select<T>(i: string, args: ...T): number
function select<T>(i: number, args: ...T): ...T
```

When called with `'#'` as the first argument, returns the number of remaining parameters passed. Otherwise, returns the subset of parameters starting with the specified index. Index can be specified from the start of the arguments (using 1 as the first argument), or from the end (using -1 as the last argument).

### setfenv

```lua
function setfenv(target: function | number, env: table)
```

Changes the environment table for target function to `env`; when `target` is not a function, it must be a number corresponding to the caller stack index, where 1 means the function that calls `setfenv`, and the environment table is returned for the corresponding function from the call stack.

### setmetatable

```lua
function setmetatable(t: table, mt: table?)
```

Changes metatable for the given table. Note that unlike `getmetatable`, this function only works on tables. If the table already has a protected metatable (has a `__metatable` field), this function errors.

### tonumber

```lua
function tonumber(s: string, base: number?): number?
```

Converts the input string to the number in base `base` (default 10) and returns the resulting number. If the conversion fails (that is, if the input string doesn't represent a valid number in the specified base), returns `nil` instead.

### tostring

```lua
function tostring(obj: any): string
```

Converts the input object to string and returns the result. If the object has a metatable with `__tostring` field, that method is called to perform the conversion.

### type

```lua
function type(obj: any): string
```

Returns the type of the object, which is one of `"nil"`, `"boolean"`, `"number"`, `"vector"`, `"string"`, `"table"`, `"function"`, `"userdata"`, `"thread"`, or `"buffer"`.

### typeof

```lua
function typeof(obj: any): string
```

Returns the type of the object; for userdata objects that have a metatable with the `__type` field *and* are defined by the host (not `newproxy`), returns the value for that key. For custom userdata objects, such as ones returned by `newproxy`, this function returns `"userdata"` to make sure host-defined types can not be spoofed.

### ipairs

```lua
function ipairs(t: table): <iterator>
```

Returns the triple (generator, state, nil) that can be used to traverse the table using a `for` loop. The traversal results in key-value pairs for the numeric portion of the table; key starts from 1 and increases by 1 on each iteration. The traversal terminates when reaching the first `nil` value (so `ipairs` can't be used to traverse array-like tables with holes).

### pairs

```lua
function pairs(t: table): <iterator>
```

Returns the triple (generator, state, nil) that can be used to traverse the table using a `for` loop. The traversal results in key-value pairs for all keys in the table, numeric and otherwise, but doesn't have a defined order.

### pcall

```lua
function pcall(f: function, args: ...any): (boolean, ...any)
```

Calls function `f` with parameters `args`. If the function succeeds, returns `true` followed by all return values of `f`. If the function raises an error, returns `false` followed by the error object. Note that `f` can yield, which results in the entire coroutine yielding as well.

### xpcall

```lua
function xpcall(f: function, e: function, args: ...any): (boolean, ...any)
```

Calls function `f` with parameters `args`. If the function succeeds, returns `true` followed by all return values of `f`. If the function raises an error, calls `e` with the error object as an argument, and returns `false` followed by the first return value of `e`. Note that `f` can yield, which results in the entire coroutine yielding as well. `e` can neither yield nor error - if it does raise an error, `xpcall` returns with `false` followed by a special error message.

### unpack

```lua
function unpack<V>(a: {V}, f: number?, t: number?): ...V
```

Returns all values of `a` with indices in `[f..t]` range. `f` defaults to 1 and `t` defaults to `#a`. Note that this is equivalent to `table.unpack`.

## Libraries

* bit32
* buffer
* coroutine
* debug
* math
* string
* table
* utf8
* vector
* os

# coroutine

## create

```lua
function coroutine.create(f: function): thread
```

Returns a new coroutine that, when resumed, will run function `f`.

## running

```lua
function coroutine.running(): thread?
```

Returns the currently running coroutine, or `nil` if the code is running in the main coroutine (depending on the host environment setup, main coroutine may never be used for running code).

## status

```lua
function coroutine.status(co: thread): string
```

Returns the status of the coroutine, which can be `"running"`, `"suspended"`, `"normal"` or `"dead"`. Dead coroutines have finished their execution and can not be resumed, but their state can still be inspected as they are not dead from the garbage collector point of view.

## wrap

```lua
function coroutine.wrap(f: function): function
```

Creates a new coroutine and returns a function that, when called, resumes the coroutine and passes all arguments along to the suspension point. When the coroutine yields or finishes, the wrapped function returns with all values returned at the suspension point.

## yield

```lua
function coroutine.yield(args: ...any): ...any
```

Yields the currently running coroutine and passes all arguments along to the code that resumed the coroutine. The coroutine becomes suspended; when the coroutine is resumed again, the resumption arguments will be forwarded to `yield` which will behave as if it returned all of them.

## isyieldable

```lua
function coroutine.isyieldable(): boolean
```

Returns `true` iff the currently running coroutine can yield. Yielding is prohibited when running inside metamethods like `__index` or C functions like `table.foreach` callback, with the exception of `pcall`/`xpcall`.

## resume

```lua
function coroutine.resume(co: thread, args: ...any): (boolean, ...any)
```

Resumes the coroutine and passes the arguments along to the suspension point. When the coroutine yields or finishes, returns `true` and all values returned at the suspension point. If an error is raised during coroutine resumption, this function returns `false` and the error object, similarly to `pcall`.

## close

```lua
function coroutine.close(co: thread): (boolean, any?)
```

Closes the coroutine which puts coroutine in the dead state. The coroutine must be dead or suspended - in particular it can't be currently running. If the coroutine that's being closed was in an error state, returns `false` along with an error object; otherwise returns `true`. After closing, the coroutine can't be resumed and the coroutine stack becomes empty.

# debug

## info

```lua
function debug.info(co: thread, level: number, s: string): ...any
function debug.info(level: number, s: string): ...any
function debug.info(f: function, s: string): ...any
```

Given a stack frame or a function, and a string that specifies the requested information, returns the information about the stack frame or function.

Each character of `s` results in additional values being returned in the same order as the characters appear in the string:

* `s` returns source path for the function
* `l` returns the line number for the stack frame or the line where the function is defined when inspecting a function object
* `n` returns the name of the function, or an empty string if the name is not known
* `f` returns the function object itself
* `a` returns the number of arguments that the function expects followed by a boolean indicating whether the function is variadic or not

For example, `debug.info(2, "sln")` returns source file, current line and function name for the caller of the current function.

## traceback

```lua
function debug.traceback(co: thread, msg: string?, level: number?): string
function debug.traceback(msg: string?, level: number?): string
```

Produces a stringified callstack of the given thread, or the current thread, starting with level `level`. If `msg` is specified, then the resulting callstack includes the string before the callstack output, separated with a newline. The format of the callstack is human-readable and subject to change.

# math

## abs

```lua
function math.abs(n: number): number
```

Returns the absolute value of `n`. Returns NaN if the input is NaN.

## acos

```lua
function math.acos(n: number): number
```

Returns the arc cosine of `n`, expressed in radians. Returns a value in `[0, pi]` range. Returns NaN if the input is not in `[-1, +1]` range.

## asin

```lua
function math.asin(n: number): number
```

Returns the arc sine of `n`, expressed in radians. Returns a value in `[-pi/2, +pi/2]` range. Returns NaN if the input is not in `[-1, +1]` range.

## atan2

```lua
function math.atan2(y: number, x: number): number
```

Returns the arc tangent of `y/x`, expressed in radians. The function takes into account the sign of both arguments in order to determine the quadrant. Returns a value in `[-pi, pi]` range.

## atan

```lua
function math.atan(n: number): number
```

Returns the arc tangent of `n`, expressed in radians. Returns a value in `[-pi/2, pi-2]` range.

## ceil

```lua
function math.ceil(n: number): number
```

Rounds `n` upwards to the next integer boundary.

## cosh

```lua
function math.cosh(n: number): number
```

Returns the hyperbolic cosine of `n`.

## cos

```lua
function math.cos(n: number): number
```

Returns the cosine of `n`, which is an angle in radians. Returns a value in `[0, 1]` range.

## deg

```lua
function math.deg(n: number): number
```

Converts `n` from radians to degrees and returns the result.

## exp

```lua
function math.exp(n: number): number
```

Returns the base-e exponent of `n`, that is `e^n`.

## floor

```lua
function math.floor(n: number): number
```

Rounds `n` downwards to previous integer boundary.

## fmod

```lua
function math.fmod(x: number, y: number): number
```

Returns the remainder of `x` modulo `y`, rounded towards zero. Returns NaN if `y` is zero.

## frexp

```lua
function math.frexp(n: number): (number, number)
```

Splits the number into a significand (a number in `[-1, +1]` range) and binary exponent such that `n = s * 2^e`, and returns `s, e`.

## ldexp

```lua
function math.ldexp(s: number, e: number): number
```

Given the significand and a binary exponent, returns a number `s * 2^e`.

## lerp

```lua
function math.lerp(a: number, b: number, t: number): number
```

Linearly interpolated between number value `a` and `b` using factor `t`, generally returning the result of `a + (b - a) * t`. When `t` is exactly `1`, the value of `b` will be returned instead to ensure that when `t` is on the interval `[0, 1]`, the result of `lerp` will be on the interval `[a, b]`.

## map

```lua
math.map(x: number, inmin: number, inmax: number, outmin: number, outmax: number): number
```

Returns a value that represents `x` mapped linearly from the input range (`inmin` to `inmax`) to the output range (`outmin` to `outmax`).

## log10

```lua
function math.log10(n: number): number
```

Returns base-10 logarithm of the input number. Returns NaN if the input is negative, and negative infinity if the input is 0. Equivalent to `math.log(n, 10)`.

## log

```lua
function math.log(n: number, base: number?): number
```

Returns logarithm of the input number in the specified base; base defaults to `e`. Returns NaN if the input is negative, and negative infinity if the input is 0.

## max

```lua
function math.max(list: ...number): number
```

Returns the maximum number of the input arguments. The function requires at least one input and will error if zero parameters are passed. If one of the inputs is a NaN, the result may or may not be a NaN.

## min

```lua
function math.min(list: ...number): number
```

Returns the minimum number of the input arguments. The function requires at least one input and will error if zero parameters are passed. If one of the inputs is a NaN, the result may or may not be a NaN.

## modf

```lua
function math.modf(n: number): (number, number)
```

Returns the integer and fractional part of the input number. Both the integer and fractional part have the same sign as the input number, e.g. `math.modf(-1.5)` returns `-1, -0.5`.

## pow

```lua
function math.pow(x: number, y: number): number
```

Returns `x` raised to the power of `y`.

## rad

```lua
function math.rad(n: number): number
```

Converts `n` from degrees to radians and returns the result.

## random

```lua
function math.random(): number
function math.random(n: number): number
function math.random(min: number, max: number): number
```

Returns a random number using the global random number generator. A zero-argument version returns a number in `[0, 1]` range. A one-argument version returns a number in `[1, n]` range. A two-argument version returns a number in `[min, max]` range. The input arguments are truncated to integers, so `math.random(1.5)` always returns 1.

## randomseed

```lua
function math.randomseed(seed: number)
```

Reseeds the global random number generator; subsequent calls to `math.random` will generate a deterministic sequence of numbers that only depends on `seed`.

## sinh

```lua
function math.sinh(n: number): number
```

Returns a hyperbolic sine of `n`.

## sin

```lua
function math.sin(n: number): number
```

Returns the sine of `n`, which is an angle in radians. Returns a value in `[0, 1]` range.

## sqrt

```lua
function math.sqrt(n: number): number
```

Returns the square root of `n`. Returns NaN if the input is negative.

## tanh

```lua
function math.tanh(n: number): number
```

Returns the hyperbolic tangent of `n`.

## tan

```lua
function math.tan(n: number): number
```

Returns the tangent of `n`, which is an angle in radians.

## noise

```lua
function math.noise(x: number, y: number?, z: number?): number
```

Returns 3D Perlin noise value for the point `(x, y, z)` (`y` and `z` default to zero if absent). Returns a value in `[-1, 1]` range.

## clamp

```lua
function math.clamp(n: number, min: number, max: number): number
```

Returns `n` if the number is in `[min, max]` range; otherwise, returns `min` when `n < min`, and `max` otherwise. If `n` is NaN, may or may not return NaN. The function errors if `min > max`.

## sign

```lua
function math.sign(n: number): number
```

Returns `-1` if `n` is negative, `1` if `n` is positive, and `0` if `n` is zero or NaN.

## round

```lua
function math.round(n: number): number
```

Rounds `n` to the nearest integer boundary. If `n` is exactly halfway between two integers, rounds `n` away from 0.

# string

## byte

```lua
function string.byte(s: string, f: number?, t: number?): ...number
```

Returns the numeric code of every byte in the input string with indices in range `[f..t]`. `f` defaults to 1 and `t` defaults to `f`, so a two-argument version of this function returns a single number. If the function is called with a single argument and the argument is out of range, the function returns no values.

## char

```lua
function string.char(args: ...number): string
```

Returns the string that contains a byte for every input number; all inputs must be integers in `[0..255]` range.

## find

```lua
function string.find(s: string, p: string, init: number?, plain: boolean?): (number?, number?, ...string)
```

Tries to find an instance of pattern `p` in the string `s`, starting from position `init` (defaults to 1). When `plain` is true, the search is using raw (case-sensitive) string equality, otherwise `p` should be a [string pattern](https://www.lua.org/manual/5.3/manual.html#6.4.1). If a match is found, returns the position of the match and the length of the match, followed by the pattern captures; otherwise returns `nil`.

## format

```lua
function string.format(s: string, args: ...any): string
```

Returns a formatted version of the input arguments using a [printf-style format string](https://en.cppreference.com/w/c/io/fprintf) `s`. The following format characters are supported:

* `c`: expects an integer number and produces a character with the corresponding character code
* `d`, `i`, `u`: expects an integer number and produces the decimal representation of that number
* `o`: expects an integer number and produces the octal representation of that number
* `x`, `X`: expects an integer number and produces the hexadecimal representation of that number, using lower case or upper case hexadecimal characters
* `e`, `E`, `f`, `g`, `G`: expects a number and produces the floating point representation of that number, using scientific or decimal representation
* `q`: expects a string and produces the same string quoted using double quotation marks, with escaped special characters if necessary
* `s`: expects a string and produces the same string verbatim

The formats support modifiers `-`, `+`, space, `#` and `0`, as well as field width and precision modifiers - with the exception of `*`.

## gmatch

```lua
function string.gmatch(s: string, p: string): <iterator>
```

Produces an iterator function that, when called repeatedly explicitly or via `for` loop, produces matches of string `s` with [string pattern](https://www.lua.org/manual/5.3/manual.html#6.4.1) `p`. For every match, the captures within the pattern are returned if present (if a pattern has no captures, the entire matching substring is returned instead).

## gsub

```lua
function string.gsub(s: string, p: string, f: function | table | string, maxs: number?): (string, number)
```

For every match of [string pattern](https://www.lua.org/manual/5.3/manual.html#6.4.1) `p` in `s`, replace the match according to `f`. The substitutions stop after the limit of `maxs`, and the function returns the resulting string followed by the number of substitutions.

When `f` is a string, the substitution uses the string as a replacement. When `f` is a table, the substitution uses the table element with key corresponding to the first pattern capture, if present, and entire match otherwise. Finally, when `f` is a function, the substitution uses the result of calling `f` with call pattern captures, or entire matching substring if no captures are present.

## len

```lua
function string.len(s: string): number
```

Returns the number of bytes in the string (equivalent to `#s`).

## lower

```lua
function string.lower(s: string): string
```

Returns a string where each byte corresponds to the lower-case ASCII version of the input byte in the source string.

## match

```lua
function string.match(s: string, p: string, init: number?): ...string?
```

Tries to find an instance of pattern `p` in the string `s`, starting from position `init` (defaults to 1). `p` should be a [string pattern](https://www.lua.org/manual/5.3/manual.html#6.4.1). If a match is found, returns all pattern captures, or entire matching substring if no captures are present, otherwise returns `nil`.

## rep

```lua
function string.rep(s: string, n: number): string
```

Returns the input string `s` repeated `n` times. Returns an empty string if `n` is zero or negative.

## reverse

```lua
function string.reverse(s: string): string
```

Returns the string with the order of bytes reversed compared to the original. Note that this only works if the input is a binary or ASCII string.

## sub

```lua
function string.sub(s: string, f: number, t: number?): string
```

Returns a substring of the input string with the byte range `[f..t]`; `t` defaults to `#s`, so a two-argument version returns a string suffix.

## upper

```lua
function string.upper(s: string): string
```

Returns a string where each byte corresponds to the upper-case ASCII version of the input byte in the source string.

## split

```lua
function string.split(s: string, sep: string?): {string}
```

Splits the input string using `sep` as a separator (defaults to `","`) and returns the resulting substrings. If separator is empty, the input string is split into separate one-byte strings.

## pack

```lua
function string.pack(f: string, args: ...any): string
```

Given a [pack format string](https://www.lua.org/manual/5.3/manual.html#6.4.2), encodes all input parameters according to the packing format and returns the resulting string. Note that Luau uses fixed sizes for all types that have platform-dependent size in Lua 5.x: short is 16 bit, long is 64 bit, integer is 32-bit and size\_t is 32 bit for the purpose of string packing.

## packsize

```lua
function string.packsize(f: string): number
```

Given a [pack format string](https://www.lua.org/manual/5.3/manual.html#6.4.2), returns the size of the resulting packed representation. The pack format can't use variable-length format specifiers. Note that Luau uses fixed sizes for all types that have platform-dependent size in Lua 5.x: short is 16 bit, long is 64 bit, integer is 32-bit and size\_t is 32 bit for the purpose of string packing.

## unpack

```lua
function string.unpack(f: string, s: string): ...any
```

Given a [pack format string](https://www.lua.org/manual/5.3/manual.html#6.4.2), decodes the input string according to the packing format and returns all resulting values. Note that Luau uses fixed sizes for all types that have platform-dependent size in Lua 5.x: short is 16 bit, long is 64 bit, integer is 32-bit and size\_t is 32 bit for the purpose of string packing.

# os

## clock

```lua
function os.clock(): number
```

Returns a high-precision timestamp (in seconds) that doesn't have a defined baseline, but can be used to measure duration with sub-microsecond precision.

## date

```lua
function os.date(s: string?, t: number?): table | string
```

Returns the table or string representation of the time specified as `t` (defaults to current time) according to `s` format string.

When `s` starts with `!`, the result uses UTC, otherwise it uses the current timezone.

If `s` is equal to `*t` (or `!*t`), a table representation of the date is returned, with keys `sec`/`min`/`hour` for the time (using 24-hour clock), `day`/`month`/`year` for the date, `wday` for week day (1..7), `yday` for year day (1..366) and `isdst` indicating whether the timezone is currently using daylight savings.

Otherwise, `s` is interpreted as a [date format string](https://www.cplusplus.com/reference/ctime/strftime/), with the valid specifiers including any of `aAbBcdHIjmMpSUwWxXyYzZ` or `%`. `s` defaults to `"%c"` so `os.date()` returns the human-readable representation of the current date in local timezone.

## difftime

```lua
function os.difftime(a: number, b: number): number
```

Calculates the difference in seconds between `a` and `b`; provided for compatibility only. Please use `a - b` instead.

## time

```lua
function os.time(t: table?): number
```

When called without arguments, returns the current date/time as a Unix timestamp. When called with an argument, expects it to be a table that contains `sec`/`min`/`hour`/`day`/`month`/`year` keys and returns the Unix timestamp of the specified date/time in UTC.

# table

## concat

```lua
function table.concat(a: {string}, sep: string?, f: number?, t: number?): string
```

Concatenate all elements of `a` with indices in range `[f..t]` together, using `sep` as a separator if present. `f` defaults to 1 and `t` defaults to `#a`.

## foreach

```lua
function table.foreach<K, V, R>(t: { [K]: V }, f: (K, V) -> R?): R?
```

Iterates over all elements of the table in unspecified order; for each key-value pair, calls `f` and returns the result of `f` if it's non-nil. If all invocations of `f` returned `nil`, returns no values. This function has been deprecated and is not recommended for use in new code; use `for` loop instead.

## foreachi

```lua
function table.foreachi<V, R>(t: {V}, f: (number, V) -> R?): R?
```

Iterates over numeric keys of the table in `[1..#t]` range in order; for each key-value pair, calls `f` and returns the result of `f` if it's non-nil. If all invocations of `f` returned `nil`, returns no values. This function has been deprecated and is not recommended for use in new code; use `for` loop instead.

## getn

```lua
function table.getn<V>(t: {V}): number
```

Returns the length of table `t`. This function has been deprecated and is not recommended for use in new code; use `#t` instead.

## maxn

```lua
function table.maxn<V>(t: {V}): number
```

Returns the maximum numeric key of table `t`, or zero if the table doesn't have numeric keys.

## insert

```lua
function table.insert<V>(t: {V}, v: V)
function table.insert<V>(t: {V}, i: number, v: V)
```

When using a two-argument version, appends the value to the array portion of the table (equivalent to `t[#t+1] = v`). When using a three-argument version, inserts the value at index `i` and shifts values at indices after that by 1. `i` should be in `[1..#t]` range.

## remove

```lua
function table.remove<V>(t: {V}, i: number?): V?
```

Removes element `i` from the table and shifts values at indices after that by 1. If `i` is not specified, removes the last element of the table. `i` should be in `[1..#t]` range. Returns the value of the removed element, or `nil` if no element was removed (e.g. table was empty).

## sort

```lua
function table.sort<V>(t: {V}, f: ((V, V) -> boolean)?)
```

Sorts the table `t` in ascending order, using `f` as a comparison predicate: `f` should return `true` iff the first parameter should be before the second parameter in the resulting table. When `f` is not specified, builtin less-than comparison is used instead. The comparison predicate must establish a strict weak ordering - sort results are undefined otherwise.

## pack

```lua
function table.pack<V>(args: ...V): { [number]: V, n: number }
```

Returns a table that consists of all input arguments as array elements, and `n` field that is set to the number of inputs.

## unpack

```lua
function table.unpack<V>(a: {V}, f: number?, t: number?): ...V
```

Returns all values of `a` with indices in `[f..t]` range. `f` defaults to 1 and `t` defaults to `#a`. Note that if you want to unpack varargs packed with `table.pack` you have to specify the index fields because `table.unpack` doesn't automatically use the `n` field that `table.pack` creates. Example usage for packed varargs: `table.unpack(args, 1, args.n)`

## move

```lua
function table.move<V>(a: {V}, f: number, t: number, d: number, tt: {V}?)
```

Copies elements in range `[f..t]` from table `a` to table `tt` if specified and `a` otherwise, starting from the index `d`.

## create

```lua
function table.create<V>(n: number, v: V?): {V}
```

Creates a table with `n` elements; all of them (range `[1..n]`) are set to `v`. When `v` is nil or omitted, the returned table is empty but has preallocated space for `n` elements which can make subsequent insertions faster. Note that preallocation is only performed for the array portion of the table - using `table.create` on dictionaries is counter-productive.

## find

```lua
function table.find<V>(t: {V}, v: V, init: number?): number?
```

Find the first element in the table that is equal to `v` and returns its index; the traversal stops at the first `nil`. If the element is not found, `nil` is returned instead. The traversal starts at index `init` if specified, otherwise 1.

## clear

```lua
function table.clear(t: table)
```

Removes all elements from the table while preserving the table capacity, so future assignments don't need to reallocate space.

## freeze

```lua
function table.freeze(t: table): table
```

Given a non-frozen table, freezes it such that all subsequent attempts to modify the table or assign its metatable raise an error. If the input table is already frozen or has a protected metatable, the function raises an error; otherwise it returns the input table. Note that the table is frozen in-place and is not being copied. Additionally, only `t` is frozen, and keys/values/metatable of `t` don't change their state and need to be frozen separately if desired.

## isfrozen

```lua
function table.isfrozen(t: table): boolean
```

Returns `true` iff the input table is frozen.

## clone

```lua
function table.clone(t: table): table
```

Returns a copy of the input table that has the same metatable, same keys and values, and is not frozen even if `t` was. The copy is shallow: implementing a deep recursive copy automatically is challenging, and often only certain keys need to be cloned recursively which can be done after the initial clone by modifying the resulting table.

# utf8

Strings in Luau can contain arbitrary bytes; however, in many applications strings representing text contain UTF8 encoded data by convention, that can be inspected and manipulated using `utf8` library.

## offset

```lua
function utf8.offset(s: string, n: number, i: number?): number?
```

Returns the byte offset of the Unicode codepoint number `n` in the string, starting from the byte position `i`. When the character is not found, returns `nil` instead.

## codepoint

```lua
function utf8.codepoint(s: string, i: number?, j: number?): ...number
```

Returns a number for each Unicode codepoint in the string with the starting byte offset in `[i..j]` range. `i` defaults to 1 and `j` defaults to `i`, so a two-argument version of this function returns the Unicode codepoint that starts at byte offset `i`.

## char

```lua
function utf8.char(args: ...number): string
```

Creates a string by concatenating Unicode codepoints for each input number.

## len

```lua
function utf8.len(s: string, i: number?, j: number?): number?
```

Returns the number of Unicode codepoints with the starting byte offset in `[i..j]` range, or `nil` followed by the first invalid byte position if the input string is malformed. `i` defaults to 1 and `j` defaults to `#s`, so `utf8.len(s)` returns the number of Unicode codepoints in string `s` or `nil` if the string is malformed.

## codes

```lua
function utf8.codes(s: string): <iterator>
```

Returns an iterator that, when used in `for` loop, produces the byte offset and the codepoint for each Unicode codepoints that `s` consists of.

# buffer

Buffer is an object that represents a fixed-size mutable block of memory.

All operations on a buffer are provided using the 'buffer' library functions.

Many of the functions accept an offset in bytes from the start of the buffer.

Offset of 0 from the start of the buffer memory block accesses the first byte.

All offsets, counts and sizes should be non-negative integer numbers.

If the bytes that are accessed by any read or write operation are outside the buffer memory, an error is thrown.

## create

```lua
function buffer.create(size: number): buffer
```

Creates a buffer of the requested size with all bytes initialized to 0.

Size limit is 1GB or 1,073,741,824 bytes.

## fromstring

```lua
function buffer.fromstring(str: string): buffer
```

Creates a buffer initialized to the contents of the string.

The size of the buffer equals to the length of the string.

## tostring

```lua
function buffer.tostring(b: buffer): string
```

Returns the buffer data as a string.

## len

```lua
function buffer.len(b: buffer): number
```

Returns the size of the buffer in bytes.

## read

```lua
function buffer.readi8(b: buffer, offset: number): number
function buffer.readu8(b: buffer, offset: number): number

function buffer.readi16(b: buffer, offset: number): number
function buffer.readu16(b: buffer, offset: number): number

function buffer.readi32(b: buffer, offset: number): number
function buffer.readu32(b: buffer, offset: number): number

function buffer.readf32(b: buffer, offset: number): number
function buffer.readf64(b: buffer, offset: number): number
```

Used to read the data from the buffer by reinterpreting bytes at the offset as the type in the argument and converting it into a number.

Available types:

| Function | Type                         | Range                            |
| -------- | ---------------------------- | -------------------------------- |
| readi8   | signed 8-bit integer         | \[-128, 127]                     |
| readu8   | unsigned 8-bit integer       | \[0, 255]                        |
| readi16  | signed 16-bit integer        | \[-32,768, 32,767]               |
| readu16  | unsigned 16-bit integer      | \[0, 65,535]                     |
| readi32  | signed 32-bit integer        | \[-2,147,483,648, 2,147,483,647] |
| readu32  | unsigned 32-bit integer      | \[0, 4,294,967,295]              |
| readf32  | 32-bit floating-point number | Single-precision IEEE 754 number |
| readf64  | 64-bit floating-point number | Double-precision IEEE 754 number |

* Floating-point numbers are read and written using a format specified by IEEE 754.
* If a floating-point value matches any of bit patterns that represent a NaN (not a number), returned value might be converted to a different quiet NaN representation.
* Read and write operations use the little endian byte order.
* Integer numbers are read and written using two's complement representation.

## write

```lua
function buffer.writei8(b: buffer, offset: number, value: number): ()
function buffer.writeu8(b: buffer, offset: number, value: number): ()

function buffer.writei16(b: buffer, offset: number, value: number): ()
function buffer.writeu16(b: buffer, offset: number, value: number): ()

function buffer.writei32(b: buffer, offset: number, value: number): ()
function buffer.writeu32(b: buffer, offset: number, value: number): ()

function buffer.writef32(b: buffer, offset: number, value: number): ()
function buffer.writef64(b: buffer, offset: number, value: number): ()
```

Used to write data to the buffer by converting the number into the type in the argument and reinterpreting it as individual bytes.

* Ranges of acceptable values can be seen in the table above.
* When writing integers, the number is converted using `bit32` library rules.
* Values that are out-of-range will take less significant bits of the full number.
* For example, writing 43,981 (0xabcd) using writei8 function will take 0xcd and interpret it as an 8-bit signed number -51.
* It is still recommended to keep all numbers in range of the target type.
* Results of converting special number values (inf/nan) to integers are platform-specific.

## readstring

```lua
function buffer.readstring(b: buffer, offset: number, count: number): string
```

Used to read a string of length 'count' from the buffer at specified offset.

## writestring

```lua
function buffer.writestring(b: buffer, offset: number, value: string, count: number?): ()
```

Used to write data from a string into the buffer at a specified offset.

If an optional 'count' is specified, only 'count' bytes are taken from the string.

Count cannot be larger than the string length.

## readbits

```lua
buffer.readbits(b: buffer, bitOffset: number, bitCount: number): number
```

Used to read a range of `bitCount` bits from the buffer, at specified offset `bitOffset`, into an unsigned integer.

`bitCount` must be in `[0, 32]` range.

## writebits

```lua
buffer.writebits(b: buffer, bitOffset: number, bitCount: number, value: number): ()
```

Used to write `bitCount` bits from `value` into the buffer at specified offset `bitOffset`.

`bitCount` must be in `[0, 32]` range.

## copy

```lua
function buffer.copy(target: buffer, targetOffset: number, source: buffer, sourceOffset: number?, count: number?): ()
```

Copy 'count' bytes from 'source' starting at offset 'sourceOffset' into the 'target' at 'targetOffset'.

It is possible for 'source' and 'target' to be the same. Copying an overlapping region inside the same buffer acts as if the source region is copied into a temporary buffer and then that buffer is copied over to the target.

If 'sourceOffset' is nil or is omitted, it defaults to 0.

If 'count' is 'nil' or is omitted, the whole 'source' data starting from 'sourceOffset' is copied.

## fill

```lua
function buffer.fill(b: buffer, offset: number, value: number, count: number?): ()
```

Sets the 'count' bytes in the buffer starting at the specified 'offset' to the 'value'.

If 'count' is 'nil' or is omitted, all bytes from the specified offset until the end of the buffer are set.

# vector

This library implements functionality for the vector type in addition to the built-in primitive operator support. Default configuration uses vectors with 3 components (`x`, `y`, and `z`). If the *4-wide mode* is enabled by setting the `LUA_VECTOR_SIZE` VM configuration to 4, vectors get an additional `w` component.

Individual vector components can be accessed using the fields `x` or `X`, `y` or `Y`, `z` or `Z`, and `w` or `W` in 4-wide mode. Since vector values are immutable, writes to individual components are not supported.

## zero/one

```lua
vector.zero
vector.one
```

Constant vectors with all components set to 0 and 1 respectively. Includes the fourth component in *4-wide mode*.

## create

```lua
vector.create(x: number, y: number, z: number): vector
vector.create(x: number, y: number, z: number, w: number): vector
```

Creates a new vector with the given component values. The first constructor sets the fourth (`w`) component to 0.0 in *4-wide mode*.

## magnitude

```lua
vector.magnitude(vec: vector): number
```

Calculates the magnitude of a given vector. Includes the fourth component in *4-wide mode*.

## normalize

```lua
vector.normalize(vec: vector): vector
```

Computes the normalized version (unit vector) of a given vector. Includes the fourth component in *4-wide mode*.

## cross

```lua
vector.cross(vec1: vector, vec2: vector): vector
```

Computes the cross product of two vectors. Ignores the fourth component in *4-wide mode* and returns the 3-dimensional cross product.

## dot

```lua
vector.dot(vec1: vector, vec2: vector): number
```

Computes the dot product of two vectors. Includes the fourth component in *4-wide mode*.

## angle

```lua
vector.angle(vec1: vector, vec2: vector, axis: vector?): number
```

Computes the angle between two vectors in radians. The axis, if specified, is used to determine the sign of the angle. Ignores the fourth component in *4-wide mode* and returns the 3-dimensional angle.

## floor

```lua
vector.floor(vec: vector): vector
```

Applies `math.floor` to every component of the input vector. Includes the fourth component in *4-wide mode*.

## ceil

```lua
vector.ceil(vec: vector): vector
```

Applies `math.ceil` to every component of the input vector. Includes the fourth component in *4-wide mode*.

## abs

```lua
vector.abs(vec: vector): vector
```

Applies `math.abs` to every component of the input vector. Includes the fourth component in *4-wide mode*.

## sign

```lua
vector.sign(vec: vector): vector
```

Applies `math.sign` to every component of the input vector. Includes the fourth component in *4-wide mode*.

## clamp

```lua
vector.clamp(vec: vector, min: vector, max: vector): vector
```

Applies `math.clamp` to every component of the input vector. Includes the fourth component in *4-wide mode*.

## max

```lua
vector.max(...: vector): vector
```

Applies `math.max` to the corresponding components of the input vectors. Includes the fourth component in *4-wide mode*. Equivalent to `vector.create(math.max((...).x), math.max((...).y), math.max((...).z), math.max((...).w))`.

## min

```lua
vector.min(...: vector): vector
```

Applies `math.min` to the corresponding components of the input vectors. Includes the fourth component in *4-wide mode*. Equivalent to `vector.create(math.min((...).x), math.min((...).y), math.min((...).z), math.min((...).w))`.

# bit32

All functions in the `bit32` library treat input numbers as 32-bit unsigned integers in `[0..4294967295]` range. The bit positions start at 0 where 0 corresponds to the least significant bit.

## arshift

```lua
function bit32.arshift(n: number, i: number): number
```

Shifts `n` by `i` bits to the right (if `i` is negative, a left shift is performed instead). The most significant bit of `n` is propagated during the shift. When `i` is larger than 31, returns an integer with all bits set to the sign bit of `n`. When `i` is smaller than `-31`, 0 is returned.

## band

```lua
function bit32.band(args: ...number): number
```

Performs a bitwise `and` of all input numbers and returns the result. If the function is called with no arguments, an integer with all bits set to 1 is returned.

## bnot

```lua
function bit32.bnot(n: number): number
```

Returns a bitwise negation of the input number.

## bor

```lua
function bit32.bor(args: ...number): number
```

Performs a bitwise `or` of all input numbers and returns the result. If the function is called with no arguments, zero is returned.

## bxor

```lua
function bit32.bxor(args: ...number): number
```

Performs a bitwise `xor` (exclusive or) of all input numbers and returns the result. If the function is called with no arguments, zero is returned.

## btest

```lua
function bit32.btest(args: ...number): boolean
```

Perform a bitwise `and` of all input numbers, and return `true` iff the result is not 0. If the function is called with no arguments, `true` is returned.

## extract

```lua
function bit32.extract(n: number, f: number, w: number?): number
```

Extracts bits of `n` at position `f` with a width of `w`, and returns the resulting integer. `w` defaults to `1`, so a two-argument version of `extract` returns the bit value at position `f`. Bits are indexed starting at 0. Errors if `f` and `f+w-1` are not between 0 and 31.

## lrotate

```lua
function bit32.lrotate(n: number, i: number): number
```

Rotates `n` to the left by `i` bits (if `i` is negative, a right rotate is performed instead); the bits that are shifted past the bit width are shifted back from the right.

## lshift

```lua
function bit32.lshift(n: number, i: number): number
```

Shifts `n` to the left by `i` bits (if `i` is negative, a right shift is performed instead). When `i` is outside of `[-31..31]` range, returns 0.

## replace

```lua
function bit32.replace(n: number, r: number, f: number, w: number?): number
```

Replaces bits of `n` at position `f` and width `w` with `r`, and returns the resulting integer. `w` defaults to `1`, so a three-argument version of `replace` changes one bit at position `f` to `r` (which should be 0 or 1) and returns the result. Bits are indexed starting at 0. Errors if `f` and `f+w-1` are not between 0 and 31.

## rrotate

```lua
function bit32.rrotate(n: number, i: number): number
```

Rotates `n` to the right by `i` bits (if `i` is negative, a left rotate is performed instead); the bits that are shifted past the bit width are shifted back from the left.

## rshift

```lua
function bit32.rshift(n: number, i: number): number
```

Shifts `n` to the right by `i` bits (if `i` is negative, a left shift is performed instead). When `i` is outside of `[-31..31]` range, returns 0.

## countlz

```lua
function bit32.countlz(n: number): number
```

Returns the number of consecutive zero bits in the 32-bit representation of `n` starting from the left-most (most significant) bit. Returns 32 if `n` is zero.

## countrz

```lua
function bit32.countrz(n: number): number
```

Returns the number of consecutive zero bits in the 32-bit representation of `n` starting from the right-most (least significant) bit. Returns 32 if `n` is zero.

## byteswap

```lua
function bit32.byteswap(n: number): number
```

Returns `n` with the order of the bytes swapped.

# Globals

## Functions

### loadstring

```lua
function loadstring(code: string, chunk: string): (...) -> (... any)?
```

{% hint style="warning" %}
This function is deprecated, use [#compile](https://v-severe.gitbook.io/docs/namespaces/luau#compile "mention") and [#load](https://v-severe.gitbook.io/docs/namespaces/luau#load "mention") instead.
{% endhint %}

### pointer\_to\_userdata

```lua
function pointer_to_userdata(address: number): userdata
```

Converts the `address` into a `userdata` for usage with memory functions, if the address is a valid instance, it is converted to match the specified class.

### delfile

```lua
function delfile(path: string): ()
```

### writefile

```lua
function writefile(path: string, content: string): ()
```

Whitelisted extensions are: `.lua`, `.txt`, `.md`, `.png`, `.dds`, `.bin`, `.gif`, `.jpg`.

### isfile

```lua
function isfile(path: string): boolean
```

### loadfile

```lua
function loadfile(path: string): (... any) -> (... any)?
```

Reads the file contents, and interprets it as Luau source-code. This is directly similar to:\\

```lua
loadstring(readfile("my_file.lua"))
```

### dofile

```lua
function dofile(path: string): ()
```

Similar to `loadfile`, however instead of returning a callback, it directly calls it.

### readfile

```lua
function readfile(path: string): string
```

### delfolder

```lua
function delfolder(path: string): ()
```

### makefolder

```lua
function makefolder(path: string): ()
```

### isfolder

```lua
function isfolder(path: string): boolean
```

### isrbxactive

```lua
function isrbxactive(): boolean
```

### isrightpressed

```lua
function isrightpressed(): boolean
```

### isleftpressed

```lua
function isleftpressed(): boolean
```

### smoothmouse\_exponential

```lua
function smoothmouse_exponential(origin: vector, target: vector, speed: number): ()
```

### smoothmouse\_linear

```lua
function smoothmouse_linear(origin: vector, target: vector, speed: number): ()
```

### mouse1press

```lua
function mouse1press(): ()
```

### mouse2press

```lua
function mouse2press(): ()
```

### mouse2click

```lua
function mouse2click(): ()
```

### mouse1click

```lua
function mouse1click(): ()
```

### keypress

```lua
function keypress(code: number): ()
```

### keyrelease

```lua
function keyrelease(code: number): ()
```

### getpressedkeys

```lua
function getpressedkeys(): { number }
```

### getpressedkey

```lua
function getpressedkey(): number
```

### setclipboard

```lua
function setclipboard(payload: string): ()
```

### getmouseposition

```lua
function getmouseposition(): vector
```

### send\_notification

```lua
function send_notification(content: string): ()
```

### queue\_on\_teleport

```lua
function queue_on_teleport(code: string): ()
```

### block\_roblox\_window

```lua
function block_roblox_window(state: boolean): ()
```

## References

### game [datamodel](https://v-severe.gitbook.io/docs/reference/engine/datamodel "mention")

### workspace [workspace](https://v-severe.gitbook.io/docs/reference/engine/workspace "mention")

### taskscheduler

A reference to Roblox's `TaskScheduler`  pointer.

# Engine

## Overview

This article, and its sub-pages document how to utilize the DataModel (aka `game` global) to interact with the game state, and hierarchy.

## Instance

### declare

```lua
function Instance.declare(settings: {
    class: string | { string },
    name: string,
    callback: {
        get: (self) -> any,
        set: (self, value: any) -> (),
        Method: (...any) -> any
    }
}): ()
```

This function is used to declare new properties, or methods to all active instances that match the specified class.

# Instance

Documentation for these functions and properties can be found [here](https://create.roblox.com/docs/reference/engine/classes/Instance).\
This object serves as the base class for everything.

## Properties

### Name

```lua
Instance.Name: string
```

### ClassName

```lua
Instance.ClassName: string
```

### Parent

```lua
Instance.Parent: Instance
```

### Data

```lua
Instance.Data: string
```

Hexadecimal representation of the Instance's address, note that this is a string, you can use `tonumber` to convert it into Lua's number representation.

## Methods

### GetTags

```lua
function Instance:GetTags(): { string }
```

### HasTag

```lua
function Instance:HasTag(name: string): boolean
```

### AddTag

```lua
function Instance:AddTag(name: string): ()
```

### RemoveTag

```lua
function Instance:RemoveTag(name: string): ()
```

### ClearTags

```lua
function Instance:ClearTags(): ()
```

### GetAttribute

```lua
function Instance:GetAttribute(name: string): ()
```

### GetAttributes

```lua
function Instance:GetAttributes(): { string }
```

### SetAttribute

```lua
function Instance:SetAttribute(name: string, value: any): ()
```

### FindFirstChildOfClass

```lua
function Instance:FindFirstChildOfClass(name: string): Instance?
```

### FindFirstChild

```lua
function Instance:FindFirstChild(name: string): Instance?
```

### FindFirstAncestorOfClass

```lua
function Instance:FindFirstAncestorOfClass(name: string): Instance?
```

### FindFirstAncestor

```lua
function Instance:FindFirstAncestor(name: string): Instance?
```

### GetChildren

```lua
function Instance:GetChildren(): { Instance }
```

### GetDescendants

```lua
function Instance:GetDescendants(): { Instance }
```

### WaitForChild

```lua
function Instance:WaitForChild(name: string): Instance?
```

### FindFirstDescendant

```lua
function Instance:FindFirstDescendant(name: string): Instance?
```

### IsAncestorOf

```lua
function Instance:IsAncestorOf(Object: Instance): boolean
```

### IsDescendantOf

```lua
function Instance:IsDescendantOf(Object: Instance): boolean
```

### Destroy

```lua
function Instance:Destroy(): ()
```

# DataModel

Documentation for these functions and properties can be found [here](https://create.roblox.com/docs/reference/engine/classes/DataModel).

## Properties

### PlaceId

```lua
Instance.PlaceId: number
```

### GameId

```lua
Instance.GameId: number
```

### JobId

```lua
Instance.JobId: string
```

## Methods

### HttpGet

```lua
function DataModel:HttpGet(url: string, content: string): unknown
```

### HttpPost

```lua
function DataModel:HttpPost(url: string, data: string, content: string, accept: string, cookie: string?, referer: string?, origin: string?): unknown
```

### GetService

```lua
function DataModel:GetService(name: string): Instance
```

### GetHwid

```lua
function DataModel:GetHwid(): string
```

# BillboardGui

Documentation for these functions and properties can be found [here](https://create.roblox.com/docs/reference/engine/classes/BillboardGui).

## Properties

### Adornee

```lua
BillboardGui.Adornee: Instance?
```

# Workspace

Documentation for these functions and properties can be found [here](https://create.roblox.com/docs/reference/engine/classes/Workspace).\\

## Properties

### CurrentCamera

```lua
Workspace.CurrentCamera: Camera?
```

# Players

Documentation for these functions and properties can be found [here](https://create.roblox.com/docs/reference/engine/classes/Players).

## Properties

### LocalPlayer

```lua
Players.LocalPlayer: Player?
```

# Camera

Documentation for these functions and properties can be found [here](https://create.roblox.com/docs/reference/engine/classes/Camera).

## Properties

### ViewportSize

```lua
Camera.ViewportSize: vector
```

### FieldOfView

```lua
Camera.FieldOfView: number?
```

### CameraSubject

```lua
Camera.CameraSubject: Instance?
```

### Position

```lua
Camera.Position: vector
```

### UpVector

```lua
Camera.UpVector: vector
```

### LookVector

```lua
Camera.LookVector: vector
```

### RightVector

```lua
Camera.RightVector: vector
```

### CFrame

```lua
Camera.CFrame: {
    Position: vector,
    
    UpVector: vector,
    RightVector: vector,
    LookVector: vector
}
```

## Methods

### WorldToScreenPoint

```lua
function Camera:WorldToScreenPoint(world: vector): (vector, boolean)
```
# BasePart

Documentation for these functions and properties can be found [here](https://create.roblox.com/docs/reference/engine/classes/BasePart).

## Properties

### Size

```lua
BasePart.Size: vector
```

### Position

```lua
BasePart.Position: vector
```

### UpVector

```lua
BasePart.UpVector: vector
```

### LookVector

```lua
BasePart.LookVector: vector
```

### RightVector

```lua
BasePart.RightVector: vector
```

### CFrame

```lua
BasePart.CFrame: {
    Position: vector,
    
    UpVector: vector,
    RightVector: vector,
    LookVector: vector
}
```

### CanCollide

```lua
BasePart.CanCollide: boolean
```

### Transparency

```lua
BasePart.Transparency: number
```

### IsNetworkSleeping

```lua
BasePart.IsNetworkSleeping: boolean
```
# Player

Documentation for these functions and properties can be found [here](https://create.roblox.com/docs/reference/engine/classes/Player).

## Properties

### Team

```lua
Player.Team: Instance?
```

### UserId

```lua
Player.UserId: number
```

### Character

```lua
Player.Character: Model?
```

### DisplayName

```lua
Player.DisplayName: string
```
# Model

Documentation for these functions and properties can be found [here](https://create.roblox.com/docs/reference/engine/classes/Model).

## Properties

### PrimaryPart

```lua
Model.PrimaryPart: BasePart?
```
# Humanoid

Documentation for these functions and properties can be found [here](https://create.roblox.com/docs/reference/engine/classes/Model).

## Properties

### MaxHealth

```lua
Humanoid.MaxHealth: number
```

### Health

```lua
Humanoid.Health: number
```
# ValueBase

Documentation for these functions and properties can be found [here](https://create.roblox.com/docs/reference/engine/classes/ValueBase).

`ObjectValue`, `Color3Value`, `NumberValue`, `IntValue`, `FloatValue`, `BoolValue`, and `StringValue` inherit from this class, for simplicity sake they don't have their own sub-page.

## Properties

### Value

```lua
ValueBase.Value: any
```
# MouseService

Documentation for these functions and properties can be found [here](https://create.roblox.com/docs/reference/engine/classes/MouseService).

## Properties

### MouseBehavior

```lua
MouseService.MouseBehavior: number
```

### MouseDeltaSensitivity

```lua
MouseService.MouseDeltaSensitivity: number
```

### MouseIconEnabled

```lua
MouseService.MouseIconEnabled: boolean
```

## Methods

### GetMouseLocation

```lua
function MouseService:GetMouseLocation(): vector
```

### SetMouseLocation

```lua
function MouseService:SetMouseLocation(screen: vector): ()
```
# RunService

## Events

You can connect to these events via `:Connect` method, which takes in a callback.

### Render

The speed of this event matches the render frequency of the overlay. It is not recommended to call memory functions here.

This event is primarily used for [drawingimmediate](https://v-severe.gitbook.io/docs/reference/namespaces/drawing/drawingimmediate "mention").

### Local

This refers to a group of events which are synchronized to match the update frequency of "Local" within the overlay.

#### PreLocal

#### PostLocal

### Model

This refers to a group of events which are synchronized to match "Model" updates within the overlay. This is perfect for `GetChildren` calls.

#### PreModel

#### PostModel

### Data

Group of events which are synchronized for the "Data" updates within the overlay, perfect for storing physics data.

#### PreData

#### PostData

# Namespaces

- [task](/docs/reference/namespaces/task.md)
- [crypt](/docs/reference/namespaces/crypt.md)
- [Drawing](/docs/reference/namespaces/drawing.md)
- [DrawingImmediate](/docs/reference/namespaces/drawing/drawingimmediate.md)
- [luau](/docs/reference/namespaces/luau.md)
- [memory](/docs/reference/namespaces/memory.md)

# task

## Functions

### defer

```lua
function task.defer(callback: function | thread, ... any) -> thread
```

### spawn

```lua
function task.spawn(callback: function | thread, ... any) -> thread
```

### wait

```lua
function task.wait(amount: number) -> number
```

### delay

```lua
function task.delay(amount: number, callback: function | thread) -> thread
```

### cancel

```lua
function task.cancel(t: thread) -> ()
```
# crypt

## Functions

### random

```lua
function crypt.random(length: number): string
```

Generates a random byte buffer of the given length. Returns a string of raw bytes.

### random\_deterministic

```lua
function crypt.random_deterministic(length: number, seed: string): string
```

Generates a deterministic random buffer of given length using seed (32 bytes). Returns a string of raw bytes.

### sha256

```lua
function crypt.hash.sha256(message: string): string
```

Computes the SHA-256 hash of the message. Returns a string of 32 bytes.

### sha512

```lua
function crypt.hash.sha512(message: string): string
```

Computes the SHA-512 hash of the message. Returns a string of 64 bytes.

### blake2b

```lua
function crypt.hash.blake2b(message: string, outlen: number?): string
```

Computes the BLAKE2b hash of the message. `outlen` is optional and defaults to 32; must be between 1 and 64. Returns a string of `outlen` bytes.

### pwhash

```lua
function crypt.pwhash(password: string, outlen: number): string
```

Derives a key from the password using Argon2id. Returns a binary key of `outlen` bytes.

### pwhash\_str

```lua
function crypt.pwhash_str(password: string): string
```

Hashes the password into a safe string for storage.

### pwhash\_str\_verify

```lua
function crypt.pwhash_str_verify(hash: string, password: string): boolean
```

Verifies the password against the hash. Returns `true` if the password matches, `false` otherwise.

### seal

```lua
function crypt.secretbox.seal(plaintext: string, nonce: string, key: string): string
```

Encrypts the plaintext using symmetric encryption with XSalsa20-Poly1305. `nonce` must be 24 bytes, `key` must be 32 bytes. Returns the ciphertext.

### open

```lua
function crypt.secretbox.open(ciphertext: string, nonce: string, key: string): string
```

Decrypts the ciphertext using symmetric decryption with XSalsa20-Poly1305. `nonce` must be 24 bytes, `key` must be 32 bytes. Returns the plaintext.

### encrypt

```lua
function crypt.aead.encrypt(plaintext: string, nonce: string, key: string, ad: string?): string
```

Encrypts the plaintext using AEAD XChaCha20-Poly1305. `nonce` and `key` are required, `ad` (additional data) is optional. Returns the ciphertext.

### decrypt

```lua
function crypt.aead.decrypt(ciphertext: string, nonce: string, key: string, ad: string?): string
```

Decrypts the ciphertext using AEAD XChaCha20-Poly1305. `nonce` and `key` are required, `ad` (additional data) is optional. Returns the plaintext.

### keypair

```lua
function crypt.box.keypair(): table
```

Generates a Curve25519 keypair. Returns a table with `public` and `secret` keys (both strings).

### encrypt

```lua
function crypt.box.encrypt(message: string, nonce: string, pub: string, sec: string): string
```

Encrypts the message using public and secret keys. `nonce` must be 24 bytes, `pub` and `sec` are 32 bytes. Returns the ciphertext.

### decrypt

```lua
function crypt.box.decrypt(ciphertext: string, nonce: string, pub: string, sec: string): string
```

Decrypts the ciphertext using public and secret keys. `nonce` must be 24 bytes, `pub` and `sec` are 32 bytes. Returns the plaintext.

### seal

```lua
function crypt.box.seal(message: string, pub: string): string
```

Anonymously seals the message for the receiver’s public key. `pub` is 32 bytes. Returns the ciphertext.

### seal\_open

```lua
function crypt.box.seal_open(ciphertext: string, pub: string, sec: string): string
```

Opens the sealed message using the receiver’s public and secret keys. `pub` and `sec` are 32 bytes. Returns the plaintext.

### beforenm

```lua
function crypt.box.beforenm(pub: string, sec: string): string
```

Computes a shared key from public and secret keys for reuse. `pub` and `sec` are 32 bytes. Returns the shared key.

### keypair

```lua
function crypt.sign.keypair(): table
```

Generates an Ed25519 signing keypair. Returns a table with `public` (32 bytes) and `secret` (64 bytes) keys.

### sign

```lua
function crypt.sign.sign(message: string, sec: string): string
```

Signs the message with the secret key. `sec` is 64 bytes. Returns the signed message.

### open

```lua
function crypt.sign.open(signed: string, pub: string): string
```

Verifies and extracts the message from the signed message. `pub` is 32 bytes. Returns the original message.

### detached

```lua
function crypt.sign.detached(message: string, sec: string): string
```

Creates a detached signature for the message. `sec` is 64 bytes. Returns the signature.

### verify\_detached

```lua
function crypt.sign.verify_detached(sig: string, message: string, pub: string): boolean
```

Verifies the detached signature against the message and public key. `pub` is 32 bytes. Returns `true` if valid, `false` otherwise.

### encode

```lua
function crypt.base64.encode(raw: string): string
```

Base64 encodes the raw string. Returns the encoded string.

### decode

```lua
function crypt.base64.decode(b64: string): string
```

Base64 decodes the string. Returns the raw bytes.

### sha256

```lua
function crypt.hmac.sha256(message: string, key: string): string
```

Computes HMAC-SHA256 of the message with the key. Returns a string of 32 bytes.

### sha512

```lua
function crypt.hmac.sha512(message: string, key: string): string
```

Computes HMAC-SHA512 of the message with the key. Returns a string of 64 bytes.

### hkdf\_sha256

```lua
function crypt.hkdf_sha256(ikm: string, salt: string, info: string, outlen: number): string
```

Performs HKDF-SHA256 key derivation. Returns a binary key of `outlen` bytes.

### encode

```lua
function crypt.json.encode(t: table): string
```

Encodes a table to JSON. See <https://create.roblox.com/docs/reference/engine/classes/HttpService#JSONEncode> for details.

### decode

```lua
function crypt.json.decode(s: string): table
```

Decodes JSON to a table. See <https://create.roblox.com/docs/reference/engine/classes/HttpService#JSONDecode> for details.

# Drawing

The `Drawing` library provides functions to create and manage graphical drawing objects.

## Functions

### clear

```lua
function Drawing.clear(): ()
```

Removes all existing drawing objects.

### new

```lua
function Drawing.new(type: string): Object
```

Creates a new drawing object of the specified type and returns it. Valid types are: "Text", "Line", "Quad", "Triangle", "Circle", "Square", "Image", "Polyline".

## Methods

### Remove

```lua
function Object:Remove(): ()
```

Permanently removes the drawing object.

## Properties

### Base

#### Visible

```lua
Object.Visible: boolean
```

#### Color

```lua
Object.Color: Color3
```

#### ZIndex

```lua
Object.ZIndex: number
```

The sort-order of the object, the higher it is, the more priority the object holds, range \[-2147483647, 2147483647].

#### Opacity

```lua
Object.Opacity: number
```

### Text

#### Text

```lua
Object.Text: string
```

#### Size

```lua
Object.Size: number
```

#### Center

```lua
Object.Center: boolean
```

#### Outline

```lua
Object.Outline: boolean
```

#### OutlineColor

```lua
Object.OutlineColor: Vector3
```

#### Position

```lua
Object.Position: Vector2
```

#### TextBounds

```lua
Object.TextBounds: Vector2
```

#### Font

```lua
Object.Font: number
```

Range \[0, 31].

### Line

#### Thickness

```lua
Object.Thickness: number
```

#### From

```lua
Object.From: Vector2
```

#### To

```lua
Object.To: Vector2
```

### Circle

#### Thickness

```lua
Object.Thickness: number
```

#### NumSides

```lua
Object.NumSides: number
```

#### Radius

```lua
Object.Radius: number
```

#### Filled

```lua
Object.Filled: boolean
```

#### Position

```lua
Object.Position: Vector2
```

### Square

#### Thickness

```lua
Object.Thickness: number
```

#### Size

```lua
Object.Size: Vector2
```

#### Position

```lua
Object.Position: Vector2
```

#### Filled

```lua
Object.Filled: boolean
```

#### Rounding

```lua
Object.Rounding: number
```

### Triangle

#### Transparency

```lua
Object.Transparency: number
```

#### Thickness

```lua
Object.Thickness: number
```

#### PointA

```lua
Object.PointA: Vector2
```

#### PointB

```lua
Object.PointB: Vector2
```

#### PointC

```lua
Object.PointC: Vector2
```

#### Filled

```lua
Object.Filled: boolean
```

### Image

#### Url

```lua
Object.Url: string
```

#### Data

```lua
Object.Data: string
```

#### Gif

```lua
Object.Gif: boolean
```

#### Delay

```lua
Object.Delay: number
```

#### Position

```lua
Object.Position: Vector2
```

#### Size

```lua
Object.Size: Vector2
```

#### Rounding

```lua
Object.Rounding: number
```

#### ImageSize

```lua
Object.ImageSize: Vector2
```

### Quad

#### PointA

```lua
Object.PointA: Vector2
```

#### PointB

```lua
Object.PointB: Vector2
```

#### PointC

```lua
Object.PointC: Vector2
```

#### PointD

```lua
Object.PointD: Vector2
```

#### Thickness

```lua
Object.Thickness: number
```

#### Filled

```lua
Object.Filled: boolean
```

### Polyline

#### Points

```lua
Object.Points: { Vector2 }
```

An array of Vector2 points that make up the polyline.

#### Thickness

```lua
Object.Thickness: number
```

The thickness of the polyline.

#### Filled

```lua
Object.Filled: boolean
```

Whether the polyline is filled or not.

# DrawingImmediate

## Overview

The traditional way of [](https://v-severe.gitbook.io/docs/reference/namespaces/drawing "mention") is [**retained mode**](https://en.wikipedia.org/wiki/Retained_mode), thus the objects that are made through it stay on the screen until removed. However, **DrawingImmediate** as the name implies, is [**immediate mode**](https://en.wikipedia.org/wiki/Immediate_mode_\(computer_graphics\)), where the lifecycle of the objects are directly influenced by [#render](https://v-severe.gitbook.io/docs/engine/runservice#render "mention").\
\
This is similar to something, like **Serotonin/Melatonin** way of "painting" objects, with the exception that the API design is heavily inspired by **Synapse V3** and **Roblox**'s RunService.

## Examples

```lua
local Players = game:GetService("Players")
local CurrentCamera = workspace.CurrentCamera

RunService.Render:Connect(function()
    for Index, Player in Players:GetChildren() do
        local Character = Player.Character
        if not Character then continue end
        
        local Head = Character:FindFirstChild("Head")
        if not Head then continue end
        
        local Screen, Visible = CurrentCamera:WorldToScreenPoint(Head.Position)
        
        if Visible then
            DrawingImmediate.OutlinedText(Screen, 14, Color3.fromRGB(125, 165, 255), 1, Player.Name, true, "Tamzen")
        end
    end
end)
```

## Functions

These functions construct an object with the respective parameters, they don't return anything, and they should be called inside `RunService.OnRender`.

### Line

```lua
function DrawingImmediate.Line(a: vector, b: vector, color: Color3, opacity: number, segments: number, thickness: number): ()
```

### Circle

```lua
function DrawingImmediate.Circle(position: vector, radius: number, color: Color3, opacity: number, thickness: number): ()
```

### FilledCircle

```lua
function DrawingImmediate.FilledCircle(position: vector, radius: number, color: Color3, opacity: number): ()
```

### Triangle

```lua
function DrawingImmediate.Triangle(a: vector, b: vector, c: vector, color: Color3, opacity: number, thickness: number): ()
```

### FilledTriangle

```lua
function DrawingImmediate.FilledTriangle(a: vector, b: vector, c: vector, color: Color3, opacity: number): ()
```

### Rectangle

```lua
function DrawingImmediate.Rectangle(position: vector, size: vector, color: Color3, opacity: number, thickness: number): ()
```

### FilledRectangle

```lua
function DrawingImmediate.FilledRectangle(position: vector, size: vector, color: Color3, opacity: number): ()
```

### Quad

```lua
function DrawingImmediate.Quad(a: vector, b: vector, c: vector, d: vector, color: Color3, opacity: number, thickness: number): ()
```

### FilledQuad

```lua
function DrawingImmediate.FilledQuad(a: vector, b: vector, c: vector, d: vector, color: Color3, opacity: number): ()
```

### Polyline

```lua
function DrawingImmediate.Polyline(points: { vector }, color: Color3, opacity: number, thickness: number): ()
```

### Text

```lua
function DrawingImmediate.Text(position: vector, size: number, color: Color3, opacity: number, text: string, center: boolean, font: string?): ()
```

### OutlinedText

```lua
function DrawingImmediate.OutlinedText(position: vector, size: number, color: Color3, opacity: number, text: string, center: boolean, font: string?): ()
```

### Image

```lua
function DrawingImmediate.Image(source: string, position: vector, size: vector, color: Color3, opacity: number, is_gif: boolean, rounding: number): ()
```

### GetTextBounds

```lua
function DrawingImmediate.GetTextBounds(font: string, size: number, text: string): vector
```

Calculates the text boundaries based on the provided `font`, `size`, and `text`. Returns a 2-dimensional vector.

# luau

## Functions

### compile

```lua
function luau.compile(source: string, options: {
    optimizationLevel: 0 | 1 | 2?,
    coverageLevel: 0 | 1 | 2?,
    debugLevel: 0 | 1 | 2?
}): string
```

Compiles the given source code into Luau bytecode. An error will be thrown if the source code contains syntax errors or other issues that prevent successful compilation.

#### Example

```lua
local bytecode = luau.compile("print('Hello, World!')", {
    optimizationLevel = 2,
    coverageLevel = 0,
    debugLevel = 1,
})

local func = load(bytecode)
func()  -- Outputs: Hello, World!
```

### load

```lua
function luau.load(bytecode: string, options: {
    debugName: string?,
    environment: { [string]: any }?,
    injectGlobals: boolean?,
    codegenEnabled: boolean?
}): (... any?) -> (... any?)
```

Loads a function from the given Luau bytecode string. An error will be thrown if the bytecode is invalid or cannot be loaded. Note that if `environment` is enabled, native code generation and optimizations are forcefully disabled.

#### Example

```lua
local bytecode = luau.compile("return 42", {
    optimizationLevel = 2,
    coverageLevel = 0,
    debugLevel = 1,
})

local func = luau.load(bytecode, "MyChunk")
print(func())  -- Outputs: 42
```

# memory

## Overview

Functions in the `memory` library allow direct low-level access to the client's memory.

These functions are unsafe, and if used incorrectly can lead to corruption / crashes, you should also be careful and always strictly type-check the read & writes

## Functions

### read

```lua
function memory.readi8(address: number): number
function memory.readi8(source: userdata, offset: number): number

function memory.readu8(address: number): number
function memory.readu8(source: userdata, offset: number): number

function memory.readi16(address: number): number
function memory.readi16(source: userdata, offset: number): number

function memory.readu16(address: number): number
function memory.readu16(source: userdata, offset: number): number

function memory.readi32(address: number): number
function memory.readi32(source: userdata, offset: number): number

function memory.readu32(address: number): number
function memory.readu32(source: userdata, offset: number): number

function memory.readi64(address: number): number
function memory.readi64(source: userdata, offset: number): number

function memory.readu64(address: number): number
function memory.readu64(source: userdata, offset: number): number

function memory.readf32(address: number): number
function memory.readf32(source: userdata, offset: number): number

function memory.readf64(address: number): number
function memory.readf64(source: userdata, offset: number): number
```

Used to read the data from the specified memory address or from the specified offset in the `userdata`.

Available types:

| Function | Type                         | Range                                                    |
| -------- | ---------------------------- | -------------------------------------------------------- |
| readi8   | signed 8-bit integer         | \[-128, 127]                                             |
| readu8   | unsigned 8-bit integer       | \[0, 255]                                                |
| readi16  | signed 16-bit integer        | \[-32,768, 32,767]                                       |
| readu16  | unsigned 16-bit integer      | \[0, 65,535]                                             |
| readi32  | signed 32-bit integer        | \[-2,147,483,648, 2,147,483,647]                         |
| readu32  | unsigned 32-bit integer      | \[0, 4,294,967,295]                                      |
| readi64  | signed 64-bit integer        | \[-9,223,372,036,854,775,808, 9,223,372,036,854,775,807] |
| readu64  | unsigned 64-bit integer      | \[0, 18,446,744,073,709,551,615]                         |
| readf32  | 32-bit floating-point number | Single-precision IEEE 754 number                         |
| readf64  | 64-bit floating-point number | Double-precision IEEE 754 number                         |

* Floating-point numbers are read and written using a format specified by IEEE 754.

### write

```lua
function memory.writei8(address: number, value: number): ()
function memory.writei8(destination: userdata, offset: number, value: number): ()

function memory.writeu8(address: number, value: number): ()
function memory.writeu8(destination: userdata, offset: number, value: number): ()

function memory.writei16(address: number, value: number): ()
function memory.writei16(destination: userdata, offset: number, value: number): ()

function memory.writeu16(address: number, value: number): ()
function memory.writeu16(destination: userdata, offset: number, value: number): ()

function memory.writei32(address: number, value: number): ()
function memory.writei32(destination: userdata, offset: number, value: number): ()

function memory.writeu32(address: number, value: number): ()
function memory.writeu32(destination: userdata, offset: number, value: number): ()

function memory.writei64(address: number, value: number): ()
function memory.writei64(destination: userdata, offset: number, value: number): ()

function memory.writeu64(address: number, value: number): ()
function memory.writeu64(destination: userdata, offset: number, value: number): ()

function memory.writef32(address: number, value: number): ()
function memory.writef32(destination: userdata, offset: number, value: number): ()

function memory.writef64(address: number, value: number): ()
function memory.writef64(destination: userdata, offset: number, value: number): ()
```

Used to write the data to the specified memory address or to the specified offset in the `userdata`.

* Ranges of acceptable values can be seen in the table above.

### readbits

```lua
function memory.readbits(address: number, bitOffset: number, bitSize: number): number
function memory.readbits(source: userdata, offset: number, bitOffset: number, bitSize: number): number
```

Used to read a range of `bitCount` bits from the source, at specified offset `bitOffset`, into an unsigned integer.

`bitCount` must be in `[0, 32]` range.

### writebits

```lua
function memory.writebits(address: number, bitOffset: number, bitSize: number, value: number): ()
function memory.writebits(destination: userdata, offset: number, bitOffset: number, bitSize: number, value: number): ()
```

Used to write a range of `bitCount` bits from the unsigned integer `value` to the destination, at specified offset `bitOffset`.

`bitCount` must be in `[0, 32]` range.

### readstring

```lua
function memory.readstring(address: number): string
function memory.readstring(source: userdata, offset: number): string
```

### writestring

```lua
function memory.writestring(address: number, value: string): ()
function memory.writestring(destination: userdata, offset: number, value: string): ()
```

Writes the bytes of the specified string to the specified memory address or to the specified offset in the `userdata`.

### readvector

```lua
function memory.readvector(address: number): vector
function memory.readvector(source: userdata, offset: number): vector
```

### writevector

```lua
function memory.writevector(address: number, value: vector): ()
function memory.writevector(destination: userdata, offset: number, value: vector): ()
```

Writes the bytes of the specified vector to the specified memory address or to the specified offset in the `userdata`.

### readbuffer

```lua
function memory.readbuffer(address: number, size: number): buffer
function memory.readbuffer(source: userdata, offset: number, size: number): buffer
```

Reads `size` bytes from the specified memory address or from the specified offset in the `userdata`, and returns a new `buffer` object containing those bytes.

{% hint style="info" %}
Note, that this function is extremely useful if you need to read multiple values at once, refer to [buffer](https://v-severe.gitbook.io/docs/luau/library/buffer "mention")documentation to learn how to take advantage of this.
{% endhint %}

### writebuffer

```lua
function memory.writebuffer(address: number, value: buffer): ()
function memory.writebuffer(destination: userdata, offset: number, value: buffer): ()
```

Writes the bytes from the specified `buffer` object to the specified memory address or to the specified offset in the `userdata`.

{% hint style="info" %}
Note, that this function is extremely useful if you need to write multiple values at once, refer to [buffer](https://v-severe.gitbook.io/docs/luau/library/buffer "mention")documentation to learn how to take advantage of this.
{% endhint %}

### rtti

```lua
function memory.rtti(address: number): string?
function memory.rtti(source: userdata, offset: number): string?
```

Given an address or a `userdata` and an offset, returns the RTTI type name if available, or nil otherwise.

* RTTI (Run-Time Type Information) is a mechanism that exposes type information at runtime. Not all objects have RTTI information.

### changed

```lua
function memory.changed(address: number, type: string, callback: (self: userdata, change: number | string, old: number | string) -> (), iterations: number?): userdata
function memory.changed(source: userdata, offset: number, type: string, callback: (self: userdata, change: number | string, old: number | string) -> (), iterations: number?): userdata
```

Watches the specified memory address or the specified offset in the `userdata` for changes. When a change is detected, the provided callback function is called with three arguments: the `userdata` itself, the new value, and the old value. `iterations` specifies how many times the callback should be invoked before the watch is automatically removed; if omitted, the watch remains active until manually removed.

Available types:

* `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `f32`, `f64`, `string`

### at

```lua
function memory.at(address: number): userdata
function memory.at(source: userdata, offset: number): userdata
```

Given an address or a `userdata` and an offset, returns a new `userdata` that points to the specified memory location.

* The returned `userdata` can be used with other `memory` functions to read from or write to that memory location.

# Classes

- [WebsocketClient](/docs/reference/classes/websocketclient.md)
- [Signal](/docs/reference/classes/signal.md)

# WebsocketClient

### Functions <a href="#functions" id="functions"></a>

#### new <a href="#new" id="new"></a>

```lua
function WebsocketClient.new(url: string) -> WebsocketClient
```

### Methods <a href="#methods" id="methods"></a>

#### Disconnect <a href="#disconnect" id="disconnect"></a>

```lua
function WebsocketClient:Disconnect() -> ()
```

#### Send <a href="#send" id="send"></a>

```lua
function WebsocketClient:Send(message: string, is_binary: boolean?) -> ()
```

### Events <a href="#events" id="events"></a>

#### DataReceived <a href="#onmessage" id="onmessage"></a>

```lua
WebsocketClient.DataReceived(payload: string, is_binary: boolean?)
```
# Signal

## Constructor <a href="#signal" id="signal"></a>

### new <a href="#new" id="new"></a>

```
function Signal.new(): Signal
```

Creates a new `Signal` object.

## Methods <a href="#connect" id="connect"></a>

### connect <a href="#connect" id="connect"></a>

```
function Signal:connect(callback: (...any) -> ()): Connection
```

Connects the specified callback function to the signal. The callback will be invoked with any arguments passed to the `Fire` method.

### fire <a href="#fire" id="fire"></a>

```
function Signal:fire(... any): ()
```

Fires the signal, invoking all connected callbacks with the provided arguments.

### wait <a href="#wait" id="wait"></a>

```
function Signal:wait(): (... any)
```

Waits for the signal to be fired and returns the arguments passed to the `Fire` method.

### once <a href="#once" id="once"></a>

```
function Signal:once(callback: (...any) -> ()): Connection
```

Connects the specified callback function to the signal, but only for a single invocation. After the signal is fired and the callback is invoked, the connection is automatically disconnected.

## Classes <a href="#connection" id="connection"></a>

### Connection

#### disconnect <a href="#disconnect" id="disconnect"></a>

```
function Connection:disconnect(): ()
```

Disconnects the connection, preventing the associated callback from being invoked when the signal is fired.







